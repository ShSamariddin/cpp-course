<HTML>
<HEAD>
  <TITLE>Win32 SEH изнутри</TITLE>
  <META charset="UTF-8">
</HEAD>
<BODY>
<H1 align=center>Win32 SEH изнутри</H1>
<P><A href="listings.zip">(листинг)</A>
<P>В своей основе, структурная обработка исключений - это сервис,
предоставляемый системой. Вся документация по <B>SEH</B>, которую вы, вероятно,
найдете, описывает одну лишь компиляторно-зависимую оболочку, созданную
<B>RTL</B> вокруг реализации <B>SEH</B> операционной системы. Я здесь рассмотрю
самые фундаментальные концепции <B>SEH</B>.
<P>Эта статья предполагает, что вы уже знакомы с <B>C++</B> и <B>Win32</B>
<P>Из всех механизмов, предоставляемых операционными системами <B>Win32®</B>,
возможно наиболее широко используемым, но не документированным является механизм
структурной обработки исключений (он же <B>Structured Exception Handling</B>,
или просто - <B>SEH</B>). Когда вы думаете о <B>Win32 SEH</B>, то, вероятно,
вспоминаете термины подобные <B>_try</B>, <B>_finally</B>, и <B>_except</B>. Вы
можете найти хорошее описания <B>SEH</B> в почти любой компетентной книге по
<B>Win32</B> (даже посредственной). Даже <B>Win32 SDK</B> имеет довольно
законченный краткий обзор использования SEH с использованием <B>_try</B>,
<B>_finally</B>, и <B>_except</B>.
<P>Почему я, принимая во внимание всю эту документацию, утверждаю, что механизм
<B>SEH</B> является не документированным? Утверждение основывается на том, что
<B>Win32 SEH</B> - это механизм, предоставляемый операционной системой. Вся
документация о <B>SEH</B>, которую вы, вероятно, найдете, описывает только
компиляторно-зависимую обертку <B>RTL</B> (<B>runtime-library</B>) над
механизмом <B>SEH</B>, реализованным на уровне операционной системы. В ключевых
словах <B>_try</B>, <B>_finally</B>, или <B>_except</B>, нет ничего магического.
Группы разработчиков из <B>Microsoft</B>, занимающиеся разработкой операционных
систем и компиляторов, определили эти ключевые слова, и то, что они делают.
Другие поставщики <B>C++</B>-компиляторов просто поддержали эту семантику.
Механизм <B>SEH</B> уровня компилятора скрывает недружелюбность базового
<B>SEH</B> уровня операционной системы, что позволило не обнародовать детали
функционирования последнего.
<P>Я получил много писем от людей, которым нужно было реализовать <B>SEH</B>
уровня компилятора, и которые не смогли найти нужной информации в документации
по подсистемам ОС. Было бы разумно с моей стороны просто указать им на исходники
<B>RTL Visual C++</B> или <B>Borland C++</B>, и забыть об этом. Увы, по какой то
неизвестной причине, реализация <B>SEH</B> на уровне компилятора, похоже,
является большой тайной. Ни <B>Microsoft</B>, ни <B>Borland</B> не предоставляют
исходных кодов самого внутреннего уровня их поддержки <B>SEH</B>.
<P>В этой статье я буду рассматривать <B>SEH</B> вплоть до самых фундаментальных
концепций. При этом я отделю реализованное операционной системой от того, что
обеспечивают компиляторы через генерацию объектного кода, и поддержку в
<B>RTL</B>. Когда я буду рассматривать код ключевых функций ОС, я буду иметь в
виду <B>Intel</B>-версию <B>Windows NT 4.0</B>. Однако, большая часть из
описанного здесь, применима и к другим процессорным платформам.
<P>Я собираюсь избегать проблем родного <B>C++</B> механизма обработки
исключений, в котором используется <B>catch()</B> вместо <B>_except</B>. В
глубине, родной <B>C++</B> механизм реализован подобно описанному здесь. Однако
он имеет некоторые дополнительные сложности, которые усложнили бы восприятие тех
концепций, которые я хочу здесь охватить.
<P>При изучении невразумительных <B>.h</B> и <B>.inc</B> файлов для составления
из отдельных частей того, что называется <B>Win32 SEH</B>, одним из лучших
источников информации, как оказалось, являются заголовочные файлы <B>IBM
OS/2</B> (особенно <B>BSEXCPT.H</B>). Если вы знаете историю <B>Microsoft</B>,
это не удивит вас. Механизмы <B>SEH</B>, описанные здесь были определены раньше,
когда <B>Microsoft</B> еще работал над <B>OS/2</B>. По этой причине, вы увидите,
что реализация <B>SEH</B> под <B>Win32</B> и <B>OS/2</B>, очень похожа.
<H2>Введение в SEH</H2>
<P>Так как подробности <B>SEH</B>, изложенные все сразу, могут испугать вас, я
начну с простых вещей, и буду постепенно переходить к более сложным. Если вы
никогда не работали c <B>SEH</B>, значит у вас нет предубеждений. Если раньше вы
использовали <B>SEH</B>, постарайтесь забыть о таких словах как <B>__try</B>,
<B>GetExceptionCode</B> и <B>EXCEPTION_EXECUTE_HANDLER</B>. Притворитесь, что
это новая для вас тема. Глубоко вздохните. Готовы? Хорошо.
<P>Представьте, что я сказал вам, что когда выполняющийся поток совершает
ошибку, ОС дает вам возможность узнать об этом. Точнее, когда поток совершает
ошибку, ОС вызывает определенную пользователем <B>callback</B>-функцию.
Функциональность этой <B>callback</B>-функции в значительной степени не
регламентирована, т.е. в процессе своей работы она может делать все, что вам
угодно. Например, она может устранить причину ошибки, или же просто проиграть
какой-нибудь <B>wav</B>-файл. Независимо оттого, что эта <B>callback</B>-функция
делает, она должна возвратить значение, которое скажет системе, что делать
дальше.
<P>Учитывая, что ваша функция будет вызвана системой, после того как произойдет
ошибка то, что она должна знать? Другими словами, какую информацию вам хотелось
бы иметь об исключении? В действительности же, ваше мнение здесь не имеет
значения, т.к. в <B>Win32</B> все решено за вас. Вызываемая, при возникновении
исключения, <B>callback</B>-функция выглядит примерно так:
<BLOCKQUOTE><PRE>EXCEPTION_DISPOSITION
 __cdecl _except_handler(
     struct _EXCEPTION_RECORD *ExceptionRecord,
     void * EstablisherFrame,
     struct _CONTEXT *ContextRecord,
     void * DispatcherContext
     );
</PRE></BLOCKQUOTE>
<P>Этот прототип, взятый из стандартного заголовочного файла <B>Win32</B>:
<B>EXCPT.H</B>, сначала выглядит немного пугающе. Но, если вы будете изучать его
не спеша, то все окажется не так уж сложно. Пока можете не обращать внимания на
тип возвращаемого значения (<B>EXCEPTION_DISPOSITION</B>). Главное, что функция
<B>_except_handler</B> имеет четыре параметра.
<P>Первый параметр <B>callback</B>-функции <B>_except_handler</B> - указатель на
структуру <B>EXCEPTION_RECORD</B>. Эта структура определена в <B>WINNT.H</B>,
следующим образом:
<BLOCKQUOTE><PRE>typedef struct _EXCEPTION_RECORD {
     DWORD ExceptionCode;
     DWORD ExceptionFlags;
 struct _EXCEPTION_RECORD *ExceptionRecord;
     PVOID ExceptionAddress;
     DWORD NumberParameters;
     DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
 }  EXCEPTION_RECORD;
</PRE></BLOCKQUOTE>
<P>Поле <B>ExceptionCode</B> - содержит код, который в операционной системе
закреплен за исключением. Вы можете посмотреть список различных кодов исключения
в заголовочном файле <B>WINNT.H</B>. Для этого надо искать директивы
<B>#define</B>, которые начинаются с <B>"STATUS_"</B>. Например, код, всем
известного, <B>STATUS_ACCESS_VIOLATION</B> - <B>0xC0000005</B>. Наиболее полный
набор кодов исключений можно найти в заголовочном файле <B>NTSTATUS.H</B> из
<B>Windows NT DDK</B>. Четвертый элемент в структуре <B>EXCEPTION_RECORD</B>:
<B>ExceptionAddress</B> - содержит адрес, где произошло исключение. На
оставшиеся поля <B>EXCEPTION_RECORD</B> можно пока не обращать внимание.
<P>Второй параметр функции <B>_except_handler</B> - содержит указатель на
установочную структуру фрейма (<B>establisher frame</B>) принадлежащую этой
<B>callback</B>-функции, т.е. на ту структуру, адрес которой заносят в
<B>FS:[0]</B> при установке <B>per-thread</B> обработчика. Это жизненно важный
параметр, но пока вы можете его игнорировать.
<P>Третий параметр <B>callback</B>-функции <B>_except_handler</B> - содержит
указатель на структуру <B>CONTEXT</B>. Эта структура содержит значения регистров
в вызвавшем исключение потоке на момент возникновения исключения. На рис.1
показано, как определена эта структура в <B>WinNT.H</B>.
<BLOCKQUOTE><PRE>typedef struct _CONTEXT
 {
     DWORD ContextFlags;
     DWORD   Dr0;
     DWORD   Dr1;
     DWORD   Dr2;
     DWORD   Dr3;
     DWORD   Dr6;
     DWORD   Dr7;
     FLOATING_SAVE_AREA FloatSave;
     DWORD   SegGs;
     DWORD   SegFs;
     DWORD   SegEs;
     DWORD   SegDs;
     DWORD   Edi;
     DWORD   Esi;
     DWORD   Ebx;
     DWORD   Edx;
     DWORD   Ecx;
     DWORD   Eax;
     DWORD   Ebp;
     DWORD   Eip;
     DWORD   SegCs;
     DWORD   EFlags;
     DWORD   Esp;
     DWORD   SegSs;
 } CONTEXT;
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 1. Структура CONTEXT.</B></CENTER>
<P>Кстати, эта же структура используется в <B>API</B>-функциях
<B>GetThreadContext</B> и <B>SetThreadContext</B>.
<P>Четвертый, заключительный, параметр <B>callback</B>-функции
<B>_except_handler</B> называется <B>DispatcherContext</B>. Его также можно пока
игнорировать.
<P>Теперь кратко резюмируем вышесказанное: мы имеем <B>callback</B>-функцию,
которая вызывается при возникновении исключений. При вызове функции ей
передаются четыре параметра, три из которых - содержат указатели на структуры.
Некоторые поля в этих структурах важны, другие не очень. Ключевой момент:
<B>callback</B>-функция <B>_except_handler</B> получает обширную информацию,
такую как, тип произошедшего исключения и где оно произошло. Используя эту
информацию, она должна решить, что ей нужно делать.
<P>Хотя меня постоянно подмывает, быстренько набросать вместе с вами типовую
программку, которая показала бы <B>callback</B>-функцию <B>_except_handler</B> в
действии, но для этого нам все еще кое-чего не хватает. В частности, откуда
операционная система узнает, какую функцию вызвать при возникновении исключения?
Ответ - есть еще одна структура, названная: <B>EXCEPTION_REGISTRATION</B>. Вы
ещё не раз встретите её в этой статье, так что не проходите мимо её описания.
Единственное место, где я смог найти формальное определение
<B>EXCEPTION_REGISTRATION</B>, файл <B>EXSUP.INC</B>, находящийся в исходниках
<B>RTL</B> из <B>Visual C++</B>:
<BLOCKQUOTE><PRE>_EXCEPTION_REGISTRATION struc
     prev    dd      ?
     handler dd      ?
 _EXCEPTION_REGISTRATION ends
</PRE></BLOCKQUOTE>
<P>Вы также можете увидеть, что в определении структуры <B>NT_TIB</B>, которое
находится в заголовочном файле <B>WINNT.H</B>, на эту структуру ссылаются как на
<B>_EXCEPTION_REGISTRATION_RECORD</B>. Увы,
<B>_EXCEPTION_REGISTRATION_RECORD</B> нигде не определена, поэтому я был
вынужден использовать определение этой структуры на ассемблере находящееся в
файле <B>EXSUP.INC</B>. Это только один пример того, что я подразумевал ранее,
когда я говорил, что <B>SEH</B> является не документированным механизмом.
<P>В любом случае, давайте вернемся к рассматриваемому вопросу. Откуда
операционная система узнает, какую функцию она должна вызвать при возникновении
исключения? Структура <B>EXCEPTION_REGISTRATION</B> состоит из двух полей,
первое, из которых вы можете пока игнорировать. Второе поле, <B>handler</B>,
содержит указатель на <B>callback</B>-функцию обработчика исключений. Имеющаяся
у нас теперь информация позволяет подойти немного ближе к ответу на наш вопрос,
но теперь вопрос будем ставить так: каким образом операционная система находит
нужный экземпляр структуры <B>EXCEPTION_REGISTRATION</B>?
<P>Чтобы ответить на этот вопрос, полезно будет вспомнить, что <B>SEH</B>
работает на поточно-зависимой основе. То есть каждый поток имеет свою
собственную <B>callback</B>-функцию обработчика исключений (<B>exception
handler</B>). В мае 1996 г. в своей колонке, я описал ключевую структуру данных
<B>Win32</B>: блок информации потока (он же <B>TEB</B> или <B>TIB</B>).
Некоторые поля этой структуры данных одинаковы в <B>Windows NT</B>, <B>Windows
95</B>, <B>Win32s</B> и <B>OS/2</B>. Первый <B>DWORD</B> в <B>TIB</B>'е -
указатель на структуру <B>EXCEPTION_REGISTRATION</B> закрепленную за текущим
потоком. На <B>Intel Win32</B> платформе, регистр <B>FS</B> всегда указывает на
текущий <B>TIB</B>. Таким образом, по адресу <B>FS:[0]</B> вы можете найти
указатель на структуру <B>EXCEPTION_REGISTRATION</B>.
<TABLE cellSpacing=0 cellPadding=0 width=659 align=center border=1>
  <TBODY>
  <TR>
    <TD align=middle height=118><IMG height=119 alt=""
      src="image002.gif"
      width=660 border=0></TD></TR>
  <TR>
    <TD align=middle><STRONG>Рисунок 2. Схема вызова функции обработчика
      исключений операционной системой.</STRONG></TD></TR></TBODY></TABLE>
<P>Наконец, сложив эти кирпичики вместе, я написал маленькую программку для
демонстрации этого очень простого описания <B>SEH</B> на уровне ОС. На рис. 3
показан файл <B>MYSEH.CPP</B>, который имеет только две функции. Функция main
использует три инлайновых ассемблерных блока. Первый блок создает в стеке
структуру <B>EXCEPTION_REGISTRATION</B> используя две операции <B>PUSH</B>
(<B>"PUSH handler"</B> и <B>"PUSH FS:[0]"</B>). <B>PUSH FS:[0]</B> сохраняет
предыдущее значение <B>FS:[0]</B> как часть этой структуры, но в настоящее время
это для нас не важно. Важно, что в стеке находится экземпляр 8-байтовой
структуры <B>EXCEPTION_REGISTRATION</B>. Следующая операция (<B>MOV
FS:[0],ESP</B>) делает так, чтобы первый <B>DWORD</B> в <B>TIB</B>’е указывал на
новую структуру <B>EXCEPTION_REGISTRATION</B>.
<BLOCKQUOTE><PRE>//==================================================
// MYSEH - Мэт Питрек 1997
// Microsoft Systems Journal, Январь 1997
// FILE: MYSEH.CPP
// To compile: CL MYSEH.CPP
//==================================================
#define WIN32_LEAN_AND_MEAN
#include <WINDOWS.H>
#include <STDIO.H>

DWORD  scratch;

EXCEPTION_DISPOSITION
__cdecl
_except_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void * EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void * DispatcherContext )
{
    unsigned i;

    // Сообщаем, что сработал наш обработчик исключений.
    printf( "Hello from an exception handler!\n" );

    // Изменяем значение регистра EAX в context record таким образом, чтобы оно
    // указывало на какое-либо, доступное для записи место в памяти.
    ContextRecord-&gt;Eax = (DWORD)&amp;scratch;

    // Просим ОС еще раз попытаться выполнить вызвавшую исключение инструкцию.
    return ExceptionContinueExecution;
}

int main()
{
    DWORD handler = (DWORD)_except_handler;

    __asm
    {                      // Создаем структуру EXCEPTION_REGISTRATION:
        push    handler    // Адрес функции обработчика исключений.
        push    FS:[0]     // Адрес предыдущего EXECEPTION_REGISTRATION.
        mov     FS:[0],ESP // Добавляем в связанный список EXECEPTION_REGISTRATION.
    }

    __asm
    {
        mov     eax,0      // Обнуляем значение регистра EAX.
        mov     [eax], 1   // Чтобы преднамеренно вызвать исключение, делаем запись
                           // по нулевому адресу.
    }

    printf( " After writing!\n" );

    __asm
    {                       // Удаляем из связанного списка EXECEPTION_REGISTRATION.
        mov     eax,[ESP]   // Получаем указатель на предыдущий
                            // EXECEPTION_REGISTRATION.
        mov     FS:[0], EAX // Устанавливаем в начале списка предыдущий
                            // EXECEPTION_REGISTRATION.
        add     esp, 8      // Удаляем из стека структуру EXECEPTION_REGISTRATION.
    }
    return 0;
}
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 3. MYSEH.CPP</B></CENTER>
<P>Если вас задаетесь вопросом: почему я создал экземпляр структуры
<B>EXCEPTION_REGISTRATION</B> в стеке, вместо того, чтобы использовать для нее
глобальную переменную, то на это есть серьезное основание. Когда вы используете
синтаксис компилятора <B>_try/_except</B>, компилятор также создает в стеке
экземпляр структуры <B>EXCEPTION_REGISTRATION</B>. Я просто показываю вам
упрощенную версию того, что сделал бы компилятор, если бы вы использовали
<B>_try/_except</B>. (<B>Примечание переводчика</B>: <I><B>Edmond/HI-TECH</B> по
поводу возможности поместить экземпляр структуры <B>EXCEPTION_REGISTRATION</B>
не в стек, а в глобальную переменную сказал следующее: Этого делать нельзя!!!
Код ядра, который управляет <B>SEH</B>, проверяет, где находится экземпляр
структуры <B>EXCEPTION_REGISTRATION</B>. Если эта структура находится не в стеке
- он вызывает аварийное исключение</I>.).
<P>Вернемся к функции main, следующий ассемблерный блок преднамеренно вызывает
ошибку, обнулив регистр <B>EAX</B> (<B>MOV EAX, 0</B>), и затем, использует
значение этого регистра как адрес памяти, по которому следующая операция
пытается произвести запись (<B>MOV DWORD PTR [EAX], 1</B>). Заключительный
ассемблерный блок удаляет этот простой обработчик исключений: сначала он
восстанавливает предыдущее содержимое <B>FS:[0]</B>, и после этого удаляет с
вершины стека запись <B>EXCEPTION_REGISTRATION</B> (<B>ADD ESP, 8</B>).
<P>Теперь, представьте, что вы выполняете <B>MYSEH.EXE</B>, и способны видеть,
что происходит. Когда выполняется инструкция <B>"MOV DWORD PTR [EAX], 1"</B>,
происходит исключение, вызванное нарушением прав доступа. Система смотрит на
<B>FS:[0]</B> в <B>TIB</B>'е, и находит указатель на экземпляр структуры
<B>EXCEPTION_REGISTRATION</B>. В этой структуре находится указатель на функцию
обработчика исключений из <B>MYSEH.CPP</B>. После этого система помещает в стек
четыре обязательных параметра (которые я описал ранее), и вызывает функцию
<B>_except_handler</B>.
<P>Код внутри <B>_except_handler</B> сначала, с помощью <B>printf</B>, выводит
на экран надпись: <I>“ Yo! I made it here!”</I>. Затем <B>_except_handler</B>
устраняет причину возникновения ошибки. Проблема, вызвавшая исключение
заключается в том, что регистр <B>EAX</B> указывает на адрес памяти, по которому
не может быть произведена запись (в данном случае, нулевой адрес). Исправление
состоит в изменении значения регистра <B>EAX</B> в структуре <B>CONTEXT</B>, так
чтобы он указывал на такое место в памяти, в которое разрешена запись. В этой
простой программе переменная типа <B>DWORD</B> (<B>scratch</B>) создана только
для этой цели. Последнее действие функции <B>_except_handler</B> - вернуть
значение <B>ExceptionContinueExecution</B>, которое определено в стандартном
файле <B>EXCPT.H</B>.
<P>Когда ОС видит, что было возвращено значение
<B>ExceptionContinueExecution</B>, она “понимает”, что вы исправили проблему, и
команда, вызвавшая исключение, должна быть выполнена снова. Так как моя функция
<B>_except_handler</B> скорректировала регистр <B>EAX</B>, чтобы он указывал на
подходящую область памяти, со второй попытки инструкция <B>"MOV DWORD PTR [EAX],
1"</B> выполняется нормально, и функции main продолжает работать дальше. Видите,
всё это было не слишком сложно, не так ли?
<H2>Погружаемся немного глубже</H2>
<P>Рассмотрев этот простой сценарий, давайте вернемся назад, и заполним
некоторые оставшиеся пробелы. Пока обработчик исключений является общим для
всего кода программы, решение нельзя назвать - совершенным. В приложении любого
размера, было бы чрезвычайно неразумно делать только одну функцию для обработки
всех тех исключений, которые могут произойти в его коде. Гораздо более разумный
сценарий заключается в том, что нужно сделать группу обработчиков исключений,
каждый из которых будет охранять определенный участок кода. Вы можете не знать
этого, но операционная система обеспечивает именно такую функциональность.
<P>Помните структуру <B>EXCEPTION_REGISTRATION</B>, которую система использует,
чтобы найти <B>callback</B>-функцию обработчика исключений? Первый член этой
структуры, который я ранее игнорировал, называется prev. На самом деле это
указатель на другую структуру <B>EXCEPTION_REGISTRATION</B>. Эта вторая
структура <B>EXCEPTION_REGISTRATION</B> может иметь совершенно другую функцию
обработчика. К тому же, его поле prev может указывать на третью структуру
<B>EXCEPTION_REGISTRATION</B>, и так далее. Другими словами, мы имеем просто
связанный список структур <B>EXCEPTION_REGISTRATION</B>. На начало этого списка
всегда указывает первый <B>DWORD</B> в <B>TIB</B> (<B>FS:[0]</B> в машинах на
основе <B>Intel</B>).
<P>Что ОС делает с этим связанным списком структур
<B>EXCEPTION_REGISTRATION</B>? Когда происходит исключение, система обходит этот
список в поисках такой структуры <B>EXCEPTION_REGISTRATION</B>, обработчик
исключений которой согласится обработать исключение. В случае <B>MYSEH.CPP</B>,
обработчик согласился обработать исключение, вернув значение
<B>ExceptionContinueExecution</B>. Обработчик исключений может также отказаться
обрабатывать исключение. В этом случае ОС переходит к следующей структуре
<B>EXCEPTION_REGISTRATION</B>, и просит её обработчик обработать исключение.
Рис. 4 иллюстрирует данный процесс. Как только система находит обработчик
исключений, который соглашается обработать исключение, она прекращает обход
связанного списка структур <B>EXCEPTION_REGISTRATION</B>.
<P>Чтобы увидеть пример обработчика исключений, который отказывается от
обработки исключения, посмотрите <B>MYSEH2.CPP</B> на рис. 5. Чтобы не усложнять
код, я немного схитрил, и использовал небольшой обработчик исключений уровня
компилятора. Функция <B>main</B> всего лишь устанавливает блок
<B>_try/_except</B>. В блоке <B>_try</B> - производится вызов функции
<B>HomeGrownFrame</B>. Код этой функции очень похож на код предыдущей программы
<B>MYSEH</B>. Она помещает <B>EXCEPTION_REGISTRATION</B> в стек, и делает так,
чтобы <B>FS:[0]</B> указывал на вершину этой структуры. После установки нового
обработчика, функция преднамеренно вызывает ошибку, производя запись в память по
нулевому адресу:
<BLOCKQUOTE><PRE>*(PDWORD)0 = 0;
</PRE></BLOCKQUOTE>
<P>Функция обработчика исключений, снова названная <B>_except_handler</B>,
сильно отличается от своей ранней версии. Код сначала распечатывает код и флажки
исключения, взятые из структуры <B>ExceptionRecord</B>, указатель на которую
функция получает в качестве параметра. Причина, по которой распечатываются
флажки исключения, станет, ясна вам позже. Так как эта функция
<B>_except_handler</B> не намерена обрабатывать исключение, она возвращает
значение <B>ExceptionContinueSearch</B>. Это заставляет операционную систему
продолжить поиск другого обработчика исключений в следующем
<B>EXCEPTION_REGISTRATION</B> из связанного списка. А теперь, можете мне
поверить, следующий установленный обработчик исключений - это обработчик из
блока <B>_try/_except</B> в функции <B>main</B>. Блок <B>_except</B> просто
распечатывает текст: <I>"Caught the exception in main()"</I>.В данном случае
обработка исключения также проста, как и его игнорирование.
<TABLE cellSpacing=0 cellPadding=0 width=703 align=center border=1>
  <TBODY>
  <TR>
    <TD align=middle height=661><IMG height=662 alt="" src="image004.gif"
      width=704 border=0></TD></TR>
  <TR>
    <TD align=middle><STRONG>Рисунок 4. Поиск нужного обработчика исключений.
      (Примечание переводчика: в оригинале этого рисунка есть ошибка. Там все
      обработчики отказываются от обработки исключения.)
</STRONG></TD></TR></TBODY></TABLE>
<BLOCKQUOTE><PRE>//==================================================
 // MYSEH2 - Мэт Питрек 1997
 // Microsoft Systems Journal, Январь 1997
 // FILE: MYSEH2.CPP
 // To compile: CL MYSEH2.CPP
 //==================================================
 #define WIN32_LEAN_AND_MEAN
 #include <WINDOWS.H>
 #include <STDIO.H>

 EXCEPTION_DISPOSITION
 __cdecl
 _except_handler(
     struct _EXCEPTION_RECORD *ExceptionRecord,
     void * EstablisherFrame,
     struct _CONTEXT *ContextRecord,
     void * DispatcherContext )
 {
     printf( " Home Grown handler: Exception Code: %08X Exception Flags %X ",
              ExceptionRecord-&gt;ExceptionCode, ExceptionRecord-&gt;ExceptionFlags );

     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 1 )
         printf( " EH_NONCONTINUABLE" );
     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 2 )
         printf( " EH_UNWINDING" );
     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 4 )
         printf( " EH_EXIT_UNWIND" );
     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 8 )
         printf( " EH_STACK_INVALID" );
     if ( ExceptionRecord-&gt;ExceptionFlags &amp; 0x10 )
         printf( " EH_NESTED_CALL" );
     printf( "\n" );

     // Отказываемся... Мы не хотим обрабатывать его... Позволяем кому-нибудь
     // другому сделать это.
     return ExceptionContinueSearch;
 }

 void HomeGrownFrame( void )
 {
     DWORD handler = (DWORD)_except_handler;

     __asm
     {                      // Создаем структуру EXCEPTION_REGISTRATION:
         push    handler    // Адрес функции нашего обработчика исключений.
         push    FS:[0]     // Адрес предыдущего EXECEPTION_REGISTRATION.
         mov     FS:[0],ESP // Добавляем в связанный список EXECEPTION_REGISTRATION.
     }

     *(PDWORD)0 = 0;        // Преднамеренно вызываем исключение.
     printf( " I should never get here!\n" );

     __asm
     {                       // Удаляем EXECEPTION_REGISTRATION из связанного списка.
        mov     eax,[ESP]    // Получаем указатель на предыдущий
                             // EXECEPTION_REGISTRATION.
        mov     FS:[0], EAX  // Устанавливаем в начале списка предыдущий
                             // EXECEPTION_REGISTRATION.
        add     esp, 8       // Удаляем из стека структуру EXECEPTION_REGISTRATION.
     }
 }

 int main()
 {
     _try
     {
         HomeGrownFrame();
     }
     _except( EXCEPTION_EXECUTE_HANDLER )
     {
         printf( " Caught the exception in main()\n" );
     }

     return 0;
}
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 5. MYSEH2.CPP </B></CENTER>
<P>Ключевая мысль: повышение контроля над выполнением программы. Когда
обработчик отказывается обрабатывать исключение, он фактически отказывается
решать, откуда, в конечном счете, будет продолжено выполнение программы. Тот
обработчик, который соглашается обработать исключение, и решает, откуда
продолжится выполнение программы после того, как будет завершена обработка
исключения. Это очень важно, но не очевидно.
<P>При использовании <B>SEH</B>, функция все равно может завершиться аварийно в
том случае, если ее <B>exception handler</B> не обработает возникшее исключение.
Например, в <B>MYSEH2</B> минимальный обработчик в функции <B>HomeGrownFrame</B>
не обрабатывает исключение. Так как кто-то дальше по цепочке обрабатывает
исключение (функция <B>main</B>), <B>printf</B> после ошибочной инструкции
никогда не выполняется. В некоторой степени, использование <B>SEH</B> напоминает
использование функций <B>setjmp</B> и <B>longjmp</B> из <B>RTL</B>.
<P>Если вы выполните <B>MYSEH2</B>, то увидите нечто удивительное в том, что она
выводит на экран. Похоже, что функция <B>_except_handler</B> вызывается дважды.
Учитывая, что вы сейчас знаете, причина ее первого вызова должна быть понятна.
Но откуда взялся второй вызов?
<BLOCKQUOTE><PRE> Home Grown handler: Exception Code: C0000005 Exception Flags 0
 Home Grown handler: Exception Code: C0000027 Exception Flags 2
                                              EH_UNWINDING
 Caught the Exception in main()
</PRE></BLOCKQUOTE>
<P>Есть очевидное различие: сравните две строки, которые начинаются с "Home
Grown Handler:". В частности флажки исключения равны 0 в первый раз, и 2 во
второй. Это подводит меня к понятию раскрутки (<B>unwinding</B>). Зайдём немного
вперёд: если <B>callback</B>-функция обработчика отказывается обрабатывать
исключение, она вызывается во второй раз. Однако это не происходит сразу же. Всё
немного сложнее. Мне нужно будет уточнить сценарий исключения в последний раз.

<P>Когда происходит исключение, система обходит список структур
<B>EXCEPTION_REGISTRATION</B>, до тех пор пока не находит обработчик исключения.
Как только он найдётся, ОС снова обходит список, до узла, который будет
обрабатывать исключение. (<B>Примечание переводчика</B>: <I>это утверждение
может ввести вас в заблуждение! Лично у меня, после его прочтения, сложилось
впечатление, что процессом раскрутки полностью управляет ОС. На самом деле, это
не так. Процесс раскрутки инициируется обработчиком, взявшимся за обработку
исключения. Более того, для проведения раскрутки, обработчику могут вообще не
понадобиться услуги ОС, т.к. у него может иметься собственный код для ее
реализации</I>.) Во время этого второго прохода ОС вызывает каждый обработчик
ещё раз, но на этот раз значение флагов исключения равно 2, что соответствует
<B>EH_UNWINDING</B> (определение <B>EH_UNWINDING</B> есть в файле
<B>EXCEPT.INC</B>, который находится в исходниках<B> RTL Visual C++</B>, но в
<B>Win32 SDK</B> его эквивалента нет).
<P>Для чего нужен <B>EH_UNWINDING</B>? Когда <B>callback</B>-функция обработчика
вызывается во второй раз (с флагом <B>EH_UNWINDING</B>), ОС даёт
функции-обработчику шанс провести очистку, которую ей надо сделать. Какую ещё
очистку? Прекрасный пример - деструктор класса в <B>C++</B>. Если обработчик
исключений отказывается обрабатывать исключение, тогда функция, которую он
защищает, обычно, не завершается в штатном режиме. Давайте рассмотрим функцию, в
которой создан объект <B>C++</B>-класса в виде локальной переменной.
Спецификация <B>C++</B> говорит, что деструктор обязан быть вызван. Второй вызов
обработчика с флажком <B>EH_UNWINDING</B> как раз, и дает возможность функции,
произвести очистку. В процессе очистки вызываются деструкторы и
<B>_finally</B>-блоки.
<P>После того, как исключение было обработано, и все предыдущие фреймы
обработчиков исключений были вызваны для раскрутки, выполнение программы может
быть продолжено с любого места, указанного обработчиком исключений. Помните, что
не достаточно просто установить указатель команд на желаемый адрес и продолжить
выполнение. Код, где продолжится выполнение, ожидает, что указатель стека и
стекового кадра (регистры <B>ESP</B> и <B>EBP</B> на процессорах <B>Intel</B>)
установлены так, чтобы указывать на кадр стека, в пределах которого было
обработано исключение. Следовательно, обработчик, принимающий определённое
исключение, отвечает за установку указателей стека и стекового кадра на те
значения, которые они имели в том кадре стека, в котором выполнялся код
<B>SEH</B>, обработавший исключение.
<TABLE cellSpacing=0 cellPadding=0 width=528 align=center border=1>
  <TBODY>
  <TR>
    <TD align=middle height=735><IMG height=736 alt="" src="image006.gif"
      width=529 border=0></TD></TR>
  <TR>
    <TD align=middle><STRONG>Рисунок 6 Схема раскрутки, вызванной исключением.
      (Примечание переводчика: на оригинальном рисунке не была обозначена та
      <B>EXCEPTION_REGISTRATION</B>, которой принадлежит обработчик, взявшийся
      за обработку исключения.) </STRONG></TD></TR></TBODY></TABLE>
<P>В общем, раскрутка вызванная исключением приводит к удалению из стека всего,
что находится ниже того стекового кадра, в котором обрабатывается исключение.
Это почти равносильно тому, как если бы те функции никогда не вызывались. Другой
эффект раскрутки состоит в удалении всех структур <B>EXCEPTION_REGISTRATION</B>,
стоящих в списке перед обработавшей исключение. Это имеет смысл, поскольку эти
структуры <B>EXCEPTION_REGISTRATIONs</B> обычно создаются в стеке. После того,
как исключение было обработано, указатели на стек и фрейм будут указывать на
более высокие адреса памяти, чем те, в которых находились удаленные из списка
структуры <B>EXCEPTION_REGISTRATIONs</B>. Рис. 6 иллюстрирует сказанное мной
(<B>Примечание переводчика</B>: <I>на этом рисунке мы видим, судя по всему,
схему раскрутки, инициированной дефолтным обработчиком исключений</I>).
<H2>Помогите! Некому обработать исключение! </H2>
<P>До сих пор я подразумевал, что ОС всегда находит обработчик где-то в
связанном списке структур <B>EXCEPTION_REGISTRATION</B>. А что случится в том
случае, если это предположение окажется неверным? (<B>Комментарий
переводчика</B>: <I>Мэт так и не ответил на этот вопрос…</I>) Но это практически
никогда не случается потому, что ОС для каждого потока не явно устанавливает
дефолтный обработчик. Дефолтный обработчик всегда является последним узлом в
связанном списке, и всегда соглашается обработать исключение. Как я покажу
позже, его работа несколько отличаются от обычной <B>callback</B>-функции
обработчика.
<P>Давайте теперь посмотрим, где именно система устанавливает свой дефолтный
обработчик. Очевидно, что это должно делаться на ранней стадии выполнения
потока, еще до того, как начнется выполнение пользовательского кода. Рис. 7
показывает написанный мной примерный псевдокод процедуры <B>BaseProcessStart</B>
(<B>BaseProcessStart</B> - это внутренняя процедура <B>Windows NT</B>,
находящаяся в <B>KERNEL32.DLL</B>). <B>BaseProcessStart</B> имеет только один
параметр: стартовый адрес потока (<B>thread's entry point</B>).
<B>BaseProcessStart</B> выполняется в контексте нового процесса, и вызывает
точку входа, чтобы начать выполнение первого потока в процессе.
<BLOCKQUOTE><PRE>BaseProcessStart( PVOID lpfnEntryPoint )
 {
     DWORD retValue
     DWORD currentESP;
     DWORD exceptionCode;

     currentESP = ESP;

     _try
     {
         NtSetInformationThread( GetCurrentThread(),
                                 ThreadQuerySetWin32StartAddress,
                                 &amp;lpfnEntryPoint, sizeof(lpfnEntryPoint) );

         retValue = lpfnEntryPoint();

         ExitThread( retValue );
     }
     _except(// код выражения-фильтра
             exceptionCode = GetExceptionInformation(),
             UnhandledExceptionFilter( GetExceptionInformation() ) )
     {
         ESP = currentESP;

         if ( !_BaseRunningInServerProcess )         // Обычный процесс
             ExitProcess( exceptionCode );
         else                                        // Сервис
             ExitThread( exceptionCode );
     }
 }
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 7. Псевдокод BaseProcessStart. </B></CENTER>
<P>Заметьте, что вызов <B>lpfnEntryPoint</B> вложен в <B>_try</B>-блок. Это тот
самый <B>_try</B>-блок, который заносит дефолтный обработчик в связанный список.
Все прочие обработчики исключений, которые будут зарегистрированы позднее, в
список будут вставлены перед этим обработчиком. Если происходит возврат из
функции <B>lpfnEntryPoint</B>, значит выполнение потока завершено нормально. В
этом случае, <B>BaseProcessStart</B> для завершения потока вызывает
<B>ExitThread</B>.
<P>С другой стороны, что произойдет, если поток вызовет исключение, которое не
будет обработано пользовательскими обработчиками исключений? В этом случае,
управление получит код находящийся после ключевого слова <B>_except</B>. В
<B>BaseProcessStart</B>, этот код вызывает <B>API UnhandledExceptionFilter</B>,
к которой я вернусь позже. Ключевой момент:<B> API UnhandledExceptionFilter</B>
- это, по сути, дефолтный обработчик исключений.
<P>Если <B>UnhandledExceptionFilter</B> возвращает значение
<B>EXCEPTION_EXECUTE_HANDLER</B>, тогда в <B>BaseProcessStart</B> выполняется
код в <B>_except</B>-блоке. Задачей этого кода является завершение текущего
процесса, что он и делает, вызывая <B>ExitProcess</B>. Если немного подумать,
это имеет смысл; общепринято что, если программа вызывает ошибку, и не
обрабатывает ее, система завершает ее процесс. В псевдокоде вы видите
подробности того, где и как это делается.
<P>К вышесказанному осталось добавить только одно. Если поток, вызвавший ошибку,
выполняется как сервис, выполняющийся в отдельном потоке, блок <B>_except</B> не
вызывает <B>ExitProcess</B> - вместо этого он вызывает <B>ExitThread</B>. Ведь
вы же не хотели бы завершать весь сервисный процесс, только потому, что один из
сервисов совершил ошибку.
<P>Так, что же делает код дефолтного обработчика исключений находящийся в
<B>UnhandledExceptionFilter</B>? Когда я задаю этот вопрос на семинарах, очень
мало людей могут ответить на него. После простой демонстрации поведения
дефолтного обработчика, обычно все становится на свои места, и люди все
понимают. Я просто запускал программу, которая преднамеренно вызывала ошибку, и
указывал на то, что случалось в результате (см. рис. 8).
<TABLE cellSpacing=0 cellPadding=0 width=340 align=center border=1>
  <TBODY>
  <TR>
    <TD align=middle height=110><IMG height=111 alt="" src="image007.gif"
      width=341 border=0></TD></TR>
  <TR>
    <TD align=middle><STRONG>Рисунок 8. Диалог, который выдается при
      возникновении необработанного программой исключения (Unhandled Exception
      Dialog). </STRONG></TD></TR></TBODY></TABLE>
<P>На верхнем уровне, <B>UnhandledExceptionFilter</B> отображает диалог, сообщая
вам, что произошла ошибка. В этот момент вам дается возможность, или закончить
проблемный процесс, или начать его отладку. Намного больше из того, что при этом
происходит, остается за кулисами, и я опишу эти вещи в конце статьи.
<P>Как я показал, при возникновении исключения, может быть выполнен (и часто
выполняется) пользовательский код. Аналогично, пользовательский код может быть
выполнен, и в процессе операции раскрутки. Этот код может и сам содержать
ошибки, и стать причиной другого исключения. По этой причине, есть еще два
значения, которые может вернуть обработчик исключений:
<B>ExceptionNestedException</B> и <B>ExceptionCollidedUnwind</B>. В то же время,
очевидно, что это довольно сложный материал, и я не собираюсь останавливаться на
нем здесь. Достаточно сложно понять даже основные факты.
<H2>SEH на уровне компилятора</H2>
<P>Пока я редко упоминал слова <B>_try</B> и <B>_except</B>, так как всё, что я
описывал до сих пор, реализуется на уровне ОС. Однако, при взгляде на кривость
двух моих маленьких программ, которые использовали, базовый <B>SEH</B>, обертка
компилятора вокруг этого механизма - смотрится гораздо лучше. Давайте теперь
посмотрим, как <B>Visual C++</B> формирует свою <B>SEH</B>-надстройку над
базовым <B>SEH</B>.
<P>Для начала, важно запомнить, что другой компилятор, используя средства
базового <B>SEH</B> уровня системы, может сделать что-то совершенно другое.
Ничто не заставляет компилятор реализовывать модель <B>_try/_except</B>, которую
описывает документация <B>Win32 SDK</B>. Например, развивающийся <B>Visual Basic
5.0</B> использует <B>SEH</B> во время выполнения кода, но структуры данных и
алгоритмы полностью отличаются от описанных здесь.
<P>Если вы читали раздел документации <B>Win32 SDK</B> о <B>SEH</B>, вам будет
понятен следующий синтаксис так называемого "основанного на кадре"
(<B>"frame-based"</B>) обработчика исключений:
<BLOCKQUOTE><PRE> try {
     // тело защищаемого кода
 }
 except (выражение-фильтр) {
     // блок обработчика исключений
 }
</PRE></BLOCKQUOTE>
<P>Проще говоря, весь код внутри <B>_try</B>-блока защищён структурой
<B>EXCEPTION_REGISTRATION</B>, которая создана в кадре стека функции. При входе
в функцию новая структура <B>EXCEPTION_REGISTRATION</B> помещается в начало
связанного списка обработчиков исключений. После завершения блока <B>try</B>,
его структура <B>EXCEPTION_REGISTRATION</B> удаляется из списка. Как я уже
говорил, адрес начала списка хранится по адресу <B>FS:[0]</B>. Таким образом,
если вы при отладке программы встречаете строчки типа:
<BLOCKQUOTE><PRE> MOV DWORD PTR FS:[00000000],ESP
</PRE></BLOCKQUOTE>
<P>или
<BLOCKQUOTE><PRE> MOV DWORD PTR FS:[00000000],ECX
</PRE></BLOCKQUOTE>
<P>вы можете быть уверены, что код устанавливает или удаляет
<B>_try/_except</B>-блок.
<P>Теперь, когда вы знаете, что блок <B>_try</B> соответствует структуре
<B>EXCEPTION_REGISTRATION</B> находящейся в стеке, вам, возможно, захочется
узнать: что известно относительно <B>callback</B>-функции закрепленной за
<B>EXCEPTION_REGISTRATION</B>? Используя терминологию <B>Win32</B>,
<B>callback</B>-функция обработчика исключений соответствует коду
выражения-фильтра. Чтобы освежить вашу память скажу, выражение-фильтр - это код
находящийся в скобках, которые идут сразу после ключевого слова <B>_except</B>.
Именно этот код решает, выполнится ли код в последующем {}-блоке.
<P>После того как вы напишите код выражения-фильтра, вы получаете возможность
решать, будет ли возникшее исключение обработано кодом данного
<B>_except</B>-блока. Код выражения-фильтра может быть очень простым, и просто
возвращать значение "<B>EXCEPTION_EXECUTE_ HANDLER</B>". С другой стороны,
выражение-фильтр могло бы вызвать функцию, которая производит сложные
вычисления, и на основе полученного результата возвращает код, который указывает
системе, что делать дальше. В общем, что это будет за код, решаете вы. Ключевой
момент: код выражения-фильтра вызывается системой (<B>callback</B>) при
возникновении исключения.
<P>То описание, которое я только что дал, является на самом деле упрощенным и
идеализированным отражением реальности, предназначенным для того, чтобы вам было
проще понять ее. На самом деле все несколько сложнее. Для начала, код
выражения-фильтра не вызывается непосредственно операционной системой. На самом
деле, поле <B>exception handler</B> в любом <B>EXCEPTION_REGISTRATION</B>
указывает на одну и ту же функцию. Эта функция находится в <B>RTL Visual
C++</B>, и называется <B>__except_handler3</B>. Код выражения-фильтра вызывается
уже из неё. Я вернусь к этому чуть позже.
<P>Другое искажение, сделанное мной для облегчения восприятия, заключается в
том, что структура <B>EXCEPTION_REGISTRATION</B> не создаётся и не разрушается
каждый раз при входе и выходе из любого <B>_try</B>-блока. Вместо этого, в
каждой функции использующей <B>SEH</B> создается только один
<B>EXCEPTION_REGISTRATION</B>. Другими словами, вы можете иметь множество
<B>_try/_except</B> конструкций в одной функции, но в стеке будет создан только
один <B>EXCEPTION_REGISTRATION</B>. Аналогично, вы могли бы сделать в функции
вложенные блоки <B>_try</B>. Однако, при этом, <B>Visual C++</B> создаст только
один <B>EXCEPTION_REGISTRATION</B>.
<P>Если единственный обработчик исключений (это упоминавшийся ранее
<B>__except_handler3</B>) покрывает весь <B>EXE</B> или <B>DLL</B>, и если
единственный <B>EXCEPTION_REGISTRATION</B> разделяет множество
<B>_try</B>-блоков, то там очевидно делается более сложная работа, чем кажется
на первый взгляд. Этот фокус реализован с помощью таблицы данных, которую вы
обычно не видите. Однако, так как общая цель этой статьи состоит в том, чтобы
разобрать <B>SEH</B> по винтикам, давайте взглянем, как это делается.
<H2>Расширенный фрейм обработки исключений</H2>
<P><B>SEH</B>, реализованный в <B>Visual C++</B>, не использует базовую
структуру <B>EXCEPTION_REGISTRATION</B>. Вместо этого, он добавляет в конец этой
структуры дополнительные поля данных. Именно эти дополнительные данные позволяют
одной функции (<B>__except_handler3</B>) обработать все исключения программы, и
управлять вызовом соответствующих выражений-фильтров и _except-блоков. Подсказка
к формату используемой в <B>Visual C++</B> расширенной структуры
<B>EXCEPTION_REGISTRATION</B> была найдена в файле <B>EXSUP.INC</B>, который
находится в исходниках <B>RTL Visual C++</B>. В этом файле, вы найдете следующее
(закомментированное) определение:
<BLOCKQUOTE><PRE> ;struct _EXCEPTION_REGISTRATION{
 ;     struct _EXCEPTION_REGISTRATION *prev;
 ;     void (*handler)(PEXCEPTION_RECORD,
 ;                     PEXCEPTION_REGISTRATION,
 ;                     PCONTEXT,
 ;                     PEXCEPTION_RECORD);
 ;     struct scopetable_entry *scopetable;
 ;     int trylevel;
 ;     int _ebp;
 ;     PEXCEPTION_POINTERS xpointers;
 ;};
</PRE></BLOCKQUOTE>
<P>С первыми двумя полями (<B>prev</B> и <B>handler</B>) вы уже знакомы. Они
составляют основу структуры <B>EXCEPTION_REGISTRATION</B>. Новыми здесь являются
последние три поля: <B>scopetable</B>, <B>trylevel</B> и <B>_ebp</B>. Поле
<B>scopetable</B> содержит адрес массива структур типа
<B>scopetable_entries</B>, в то время как поле <B>trylevel</B> по существу
содержит индекс в этом массиве. Последнее поле, <B>_ebp</B> - значение указателя
кадра стека (<B>EBP</B>) до создания структуры
<B>EXCEPTION_REGISTRATION</B>.
<P>Это не случайно, что поле <B>_ebp</B> стало частью расширенной структуры
<B>EXCEPTION_REGISTRATION</B>. Оно включается в структуру операцией <B>PUSH
EBP</B>, с которой начинается большинство функций. Это даёт возможность
обращаться к другим полям структуры <B>EXCEPTION_REGISTRATION</B> с помощью
отрицательного смещения от указателя кадра. Например, поле <B>trylevel</B>
находится по адресу <B>[EBP-04]</B>, указатель <B>scopetable</B> находится по
адресу <B>[EBP-08]</B> и т.д.
<P>Сразу вслед за расширенной структурой <B>EXCEPTION_REGISTRATION</B>,
<B>Visual C++</B> кладёт в стек два дополнительных значения. В значении
<B>DWORD</B>, которое он кладёт в первую очередь, хранится указатель на
структуру <B>EXCEPTION_POINTERS</B> (стандартную структуру <B>Win32</B>). Это
указатель, который возвращает <B>API</B>-функция <B>GetExceptionInformation</B>.
Хотя документация <B>SDK</B> подразумевает, что <B>GetExceptionInformation</B>
является стандартной <B>API</B>-функцией <B>Win32</B>, на самом же деле это
встроенная функция компилятора. Когда вы вызываете эту функцию, <B>Visual
C++</B> генерирует следующее:
<BLOCKQUOTE><PRE> MOV EAX,DWORD PTR [EBP-14]
</PRE></BLOCKQUOTE>
<P>Так же, как и <B>GetExceptionInformation</B>, встроенной функцией
компилятора, является связанная с ней функция <B>GetExceptionCode</B>.
<B>GetExceptionCode</B> просто находит, и возвращает значение поля,
принадлежащего одной из структур данных, возвращенных
<B>GetExceptionInformation</B>. Я надеюсь что читатель, в качестве упражнения,
самостоятельно выяснит, что делают, следующие команды, которые <B>Visual C++</B>
генерирует для <B>GetExceptionCode</B>:
<BLOCKQUOTE><PRE> MOV EAX,DWORD PTR [EBP-14]
 MOV EAX,DWORD PTR [EAX]
 MOV EAX,DWORD PTR [EAX]
</PRE></BLOCKQUOTE>
<P>Вернемся к расширенной структуре <B>EXCEPTION_REGISTRATION</B>. В восьми
байтах от её начала <B>Visual C++</B> резервирует значение <B>DWORD</B> для того
значения указателя стека (<B>ESP</B>), которое он имеет сразу после исполнения
кода пролога функции. Этот <B>DWORD</B> - нормальное значение регистра
<B>ESP</B> во время выполнения функции (конечно, кроме тех случаев, когда перед
вызовом другой функции параметры кладутся в стек).
<P>Похоже, я вывалил на вас тонну информации. Прежде чем двигаться дальше,
давайте взглянем на стандартный <B>SEH</B>-фрейм, который создаёт <B>Visual
C++</B> для функции, использующей <B>SEH</B>:
<BLOCKQUOTE><PRE> EBP-00 _ebp
 EBP-04 trylevel
 EBP-08 указатель на таблицу scopetable
 EBP-0C адрес функции обработчика
 EBP-10 Указатель на предыдущую EXCEPTION_REGISTRATION
 EBP-14 GetExceptionPointers
 EBP-18 Обычное значение регистра ESP в фрейме
</PRE></BLOCKQUOTE>
<P>С точки зрения ОС, существуют только два поля, из которых состоит базовая
структура <B>EXCEPTION_REGISTRATION</B>: указатель prev в <B>[EBP-10]</B> и
указатель функцию обработчика в <B>[EBP-0Ch]</B>. Остальное содержимое фрейма
является специфическим расширением <B>Visual C++</B>. Теперь, зная всё это,
давайте посмотрим на процедуру из <B>RTL Visual C++</B>, которая воплощает
<B>SEH</B> на уровне компилятора: <B>__except_handler3</B>.
<H2>__except_handler3 и scopetable </H2>
<P>Я не могу отправить вас к исходникам <B>RTL Visual C++</B>, чтобы вы сами
посмотрели функцию <B>__except_handler3</B>, потому, что её там нет. Вместо
этого вам придётся иметь дело с написанной мной версией этой функции в
псевдокоде (см. рис. 9).
<BLOCKQUOTE><PRE>int __except_handler3(
     struct _EXCEPTION_RECORD * pExceptionRecord,
     struct EXCEPTION_REGISTRATION * pRegistrationFrame,
     struct _CONTEXT *pContextRecord,
     void * pDispatcherContext )
 {
     LONG filterFuncRet
     LONG trylevel
     EXCEPTION_POINTERS exceptPtrs
     PSCOPETABLE pScopeTable

     CLD     // Сбрасываем флаг направления (не делайте никаких допущений!)

     // Если ни один из битов: EXCEPTION_UNWINDING, или EXCEPTION_EXIT_UNWIND,
     // не установлен, то обработчик работает
     // в своем основном режиме (т.е. он работает не в режиме раскрутки).

     if ( ! (pExceptionRecord-&gt;ExceptionFlags
             &amp; (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) )
     {
         // Создаем в стеке структуру EXCEPTION_POINTERS.
         exceptPtrs.ExceptionRecord = pExceptionRecord;
         exceptPtrs.ContextRecord = pContextRecord;

         // Помещаем указатель на EXCEPTION_POINTERS в стек на 4 байта ниже
         // SEH-фрейма.
         // Смотри ассемблерный код функции GetExceptionInformation.
         *(PDWORD)((PBYTE)pRegistrationFrame - 4) = &amp;exceptPtrs;

         // Получаем начальное значение поля "trylevel".
         trylevel = pRegistrationFrame-&gt;trylevel

         // Получаем указатель на массив scopetable.
         scopeTable = pRegistrationFrame-&gt;scopetable;

 search_for_handler:

         if ( pRegistrationFrame-&gt;trylevel != TRYLEVEL_NONE )
         {
             if ( pRegistrationFrame-&gt;scopetable[trylevel].lpfnFilter )
             {
                 PUSH EBP // Сохраняем значение регистра EBP для этого фрейма.

                 // !!!Очень важно!!!  Переключение на оригинальное значение регистра
                 // EBP.  Это позволяет иметь, в пределах фрейма, одно и
                 // тоже значение в регистре EBP, как до возникновения исключения,
                 // так и после него.
                 EBP = &amp;pRegistrationFrame-&gt;_ebp

                 // Вызываем функцию фильтра.
                 filterFuncRet = scopetable[trylevel].lpfnFilter();

                 POP EBP // Восстанавливаем значение регистра EBP нужное для этого
                         // фрейма обработчика.

                 if ( filterFuncRet != EXCEPTION_CONTINUE_SEARCH )
                 {
                     if ( filterFuncRet &lt; 0 ) // EXCEPTION_CONTINUE_EXECUTION
                         return ExceptionContinueExecution;

                     // Если управление дошло до этого места, значит фильтр вернул
                     // значение EXCEPTION_EXECUTE_HANDLER.
                     scopetable == pRegistrationFrame-&gt;scopetable

                     // С помощью следующей функции ОС фактически производит очистку
                     // зарегистрированных фреймов.
                     // Эта функция рекурсивная.
                     __global_unwind2( pRegistrationFrame );

                     // Когда выполнение доходит до этого места, все фреймы,
                     // зарегистрированные после фрейма обработчика обрабатывающего
                     // исключение, уже очищены.
                     EBP = &amp;pRegistrationFrame-&gt;_ebp

                     __local_unwind2( pRegistrationFrame, trylevel );

                     // NLG == "non-local-goto" (setjmp/longjmp stuff)
                     __NLG_Notify( 1 );  // EAX == scopetable-&gt;lpfnHandler

                     // Устанавливаем текущий trylevel относительно того элемента
                     // SCOPETABLE,
                     // который использовался, когда был найден обработчик.
                     pRegistrationFrame-&gt;trylevel = scopetable-&gt;previousTryLevel;

                     // Вызываем код _except-блока.  Он не возвращает сюда
                     // управление.
                     pRegistrationFrame-&gt;scopetable[trylevel].lpfnHandler();
                 }
             }

             scopeTable = pRegistrationFrame-&gt;scopetable;
             trylevel = scopeTable-&gt;previousTryLevel

             goto search_for_handler;
         }
         else    // trylevel == TRYLEVEL_NONE
         {
             retvalue == DISPOSITION_CONTINUE_SEARCH;
         }
     }
     else    // Установлен какой-то из флажков: EXCEPTION_UNWINDING или
             // EXCEPTION_EXIT_UNWIND.
     {
         PUSH EBP    // Сохраняем значение регистра EBP.
         EBP = pRegistrationFrame-&gt;_ebp  // Устанавливаем значение регистра EBP для
                                         // __local_unwind2

         __local_unwind2( pRegistrationFrame, TRYLEVEL_NONE )

         POP EBP     // Восстанавливаем значение регистра EBP/

         retvalue == DISPOSITION_CONTINUE_SEARCH;
     }
 }
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 9. Псевдокод __except_handler3.</B></CENTER>
<P>Хотя вы увидите в <B>__except_handler3</B> большое количество кода, помните,
что это всего лишь <B>callback</B>-функция, вызываемая при возникновении
исключения, подобная той, которую я описал в начале этой статьи. Она имеет
четыре параметра, аналогичные тем, которые имеют изготовленные мной функции
<B>MYSEH.EXE</B> и <B>MYSEH2.EXE</B>. На самом верхнем уровне, функция
<B>__except_handler3</B>, с помощью оператора <B>if</B>, разбита на две части.
Это сделано потому, что функция может быть вызвана в двух режимах: в обычном
режиме (в этом режиме функция вызывается при возникновении исключения) и в
режиме раскрутки (в этом режиме функция вызывается в процессе раскрутки).
Большая часть функции предназначена работы в обычном режиме.
<P>
<P>Сначала этот код создает в стеке структуру <B>EXCEPTION_POINTERS</B>,
инициализируя ее двумя параметрами, переданными в <B>__except_handler3</B>.
Адрес этой структуры, которую в псевдокоде я назвал: <B>exceptPtrs</B>,
помещается по адресу <B>[EBP-14]</B>. Этим производится инициализация указателя,
который используют функции <B>GetExceptionInformation</B> и
<B>GetExceptionCode</B>.
<P>Затем, <B>__except_handler3</B> получает текущее значение <B>trylevel</B> из
фрейма <B>EXCEPTION_REGISTRATION</B> (в <B>[EBP-04]</B>). Значение поля
<B>trylevel</B> используется в качестве индекса в массиве <B>scopetable</B>,
благодаря которому множество <B>_try</B>-блоков (в том числе, и вложенных)
находящиеся в одной функции, используют одну и туже структуру
<B>EXCEPTION_REGISTRATION</B>. Каждый элемент <B>scopetable</B> выглядит
следующим образом:
<BLOCKQUOTE><PRE>typedef struct _SCOPETABLE
 {
     DWORD       previousTryLevel;
     DWORD       lpfnFilter
     DWORD       lpfnHandler
} SCOPETABLE, *PSCOPETABLE;
</PRE></BLOCKQUOTE>
<P>Назначение второго и третьего поля в <B>SCOPETABLE</B> понять не сложно. Они
содержат адреса кодов выражения-фильтра и соответствующего <B>_except</B>-блока.
Понять назначение поля <B>previousTryLevel</B> немного сложнее. В общем, оно
нужно для вложенных <B>try</B>-блоков. Важно, что для каждого <B>_try</B>-блока
в функции существует один элемент в <B>SCOPETABLE</B>.
<P>Как я уже говорил, текущий <B>trylevel</B> определяет используемый элемент в
массиве <B>scopetable</B>. Этот элемент, в свою очередь, определяет адреса
выражения-фильтра и <B>_except</B>-блока. Теперь рассмотрим сценарий, когда один
<B>_try</B>-блок вложен в другой. Если выражение-фильтр внутреннего
<B>_try</B>-блока решает что связанный с ним <B>_except</B>-блок не будет
обрабатывать возникшее исключение, о нём должно быть проинформировано
выражение-фильтр внешнего <B>_try</B>-блока. Каким образом
<B>__except_handler3</B> узнает, какой элемент <B>SCOPETABLE</B> соответствует
внешнему <B>_try</B>-блоку? Индекс этого элемента содержится в поле
<B>previousTryLevel</B>, принадлежащем элементу <B>SCOPETABLE</B>. Используя эту
схему, вы сможете создать произвольное количество вложенных <B>_try</B>-блоков.
Поле <B>previousTryLevel</B> используется как узел в связанном списке возможных
обработчиков исключений в пределах функции. В последнем элементе этого списка,
поле <B>trylevel</B> содержит значение <B>0xFFFFFFFF</B>.
<P>Вернемся к коду функции <B>__except_handler3</B>. После того, как текущий
<B>trylevel</B> получен, она берет соответствующий элемент <B>SCOPETABLE</B>, и
вызывает указанный в нем код выражения-фильтра. Если выражение-фильтр возвращает
значение <B>EXCEPTION_CONTINUE_SEARCH</B>, функция <B>__except_handler3</B>
переходит к следующему элементу <B>SCOPETABLE</B>, индекс которого указан в поле
<B>previousTryLevel</B>. Если в процессе перебора списка подходящий обработчик
не найден, функция <B>__except_handler3</B> возвращает значение
<B>DISPOSITION_CONTINUE_SEARCH</B>, которое заставляет систему перейти к
следующему фрейму <B>EXCEPTION_REGISTRATION</B>.
<P>Если выражение-фильтр возвращает значение <B>EXCEPTION_EXECUTE_HANDLER</B>,
значит, исключение должно быть обработано кодом соответствующего
<B>_except</B>-блока. Значит, все предыдущие фреймы
<B>EXCEPTION_REGISTRATION</B> должны быть удалены из списка, и должен быть
выполнен код <B>_except</B>-блока. Первая из этих технических задач решается
вызовом функции <B>__global_unwind2</B>, которую я опишу позже. После кода,
совершающего очистку, который я пока проигнорирую, исполнение продолжается в
<B>_except</B>-блоке. Странно, что управление, никогда не возвращается из
<B>_except</B>-блока, несмотря на то, что <B>__except_handler3</B> вызывает его
с помощью инструкции <B>CALL</B>.
<P>Как устанавливается текущее значение <B>trylevel</B>? Это делается
компилятором, который "на лету" изменяет поле <B>trylevel</B> в расширенной
структуре <B>EXCEPTION_REGISTRATION</B>. Если вы исследуете ассемблерный код,
который был сгенерирован для функции, использующей <B>SEH</B>, то в различных
местах функции вы увидите код, который изменяет текущее значение trylevel в
<B>[EBP-04]</B>.
<P>Почему, несмотря на то, что функция <B>__except_handler3</B> передает
управление <B>_except</B>-блоку с помощью инструкции <B>CALL</B>, управление к
ней никогда не возвращается? Так как операция <B>CALL</B> помещает адрес
возврата в стек, вы наверно подумали, что код <B>_except</B>-блока портит стек.
Если вы исследуете код сгенерированный для <B>_except</B>-блока, то увидите, что
первым делом он загружает в регистр <B>ESP</B> значение (<B>DWORD</B>), которое
находится в стеке на 8 байтов ниже структуры <B>EXCEPTION_REGISTRATION</B>. Как
часть своего кода пролога, функция сохраняет значение <B>ESP</B>, чтобы блок
_except мог получить его позже.
<H2>Программа ShowSEHFrames</H2>
<P>Если сейчас вы чувствуете, что немного ошеломлены вещами наподобие
<B>EXCEPTION_REGISTRATIONs</B>, <B>scopetables</B>, <B>trylevels</B>,
выражениями-фильтрами и раскруткой, то скажу вам, что в начале я тоже прошел
через это. Тему: <I>"SEH на уровне компилятора"</I>, нельзя изучить постепенно.
По отдельности большая ее часть не имеет смысла, если вы не воспринимаете её всю
как единое целое. Когда я сталкиваюсь с большим количеством теории я стараюсь
писать код, использующий концепции, которые я изучаю. Если код работает, значит
(обычно) что я все понял правильно.
<P>На рис. 10 показан исходный код программы <B>ShowSEHFrames.EXE</B>. Она
использует<B> _try/_except</B>-блоки, чтобы создать список из нескольких<B>
Visual C++ SEH</B>-фреймов. Впоследствии, она отображает информацию о каждом
фрейме, а также структуры <B>scopetable</B>, которые <B>Visual C++</B> создаёт
для каждого <B>SEH</B>-фрейма. Программа не вызывает и не ожидает никаких
исключений. Я включил все <B>_try</B>-блоки для того, чтобы <B>Visual C++</B>
создал множество кадров <B>EXCEPTION_REGISTRATION</B>, с множеством элементов
<B>scopetable</B> в них.
<P>В <B>ShowSEHFrames</B> важны следующие функции: <B>WalkSEHFrames</B> и
<B>ShowSEHFrame</B>. <B>WalkSEHFrames</B> сначала выводит на экран адрес функции
<B>__except_handler3</B> (причина, по которой это делается, станет ясна вам чуть
позже). Затем, функция получает указатель на начало списка обработчиков
исключений из <B>FS:[0]</B>, и обходит каждый его узел. Все узлы имеют тип
<B>VC_EXCEPTION_REGISTRATION</B>, который является структурой, которую я
определил, чтобы описать <B>Visual C++ SEH</B>-фрейм. <B>WalkSEHFrames</B>
передает в функцию <B>ShowSEHFrame</B> указатель на каждый узел в списке.
<BLOCKQUOTE><PRE>//==================================================
 // ShowSEHFrames - Мэт Питрек 1997
 // Microsoft Systems Journal, Февраль 1997
 // FILE: ShowSEHFrames.CPP
 // To compile: CL ShowSehFrames.CPP
 //==================================================
 #define WIN32_LEAN_AND_MEAN
 #include <WINDOWS.H>
 #include <STDIO.H>
 #pragma hdrstop

 //---------------------------------------------------------------------------
 // !!! ВНИМАНИЕ !!!  Эта программа будет компилироваться только в Visual C++,
 // т.к. использует специфичные для Visual C++ структуры данных.
 //---------------------------------------------------------------------------

 #ifndef _MSC_VER
 #error Visual C++ Required (Visual C++ specific information is displayed)
 #endif

 //----------------------------------------------------------------------------
 // Structure Definitions
 //----------------------------------------------------------------------------

 // Структура данных, используемая в качестве основного SEH-фрейма, определенного
 // на уровне ОС.

 struct EXCEPTION_REGISTRATION
 {
     EXCEPTION_REGISTRATION* prev;
     FARPROC                 handler;
 };


 // Структура (-ы) данных на которую указывает расширенный SEH-фрейм, используемый
 // на уровне Visual C++.

 struct scopetable_entry
 {
     DWORD       previousTryLevel;
     FARPROC     lpfnFilter;
     FARPROC     lpfnHandler;
 };

 // Расширенная структура данных, используемая в качестве SEH-фрейма, определенного
 // на уровне Visual C++.

 struct VC_EXCEPTION_REGISTRATION : EXCEPTION_REGISTRATION
 {
     scopetable_entry *  scopetable;
     int                 trylevel;
     int                 _ebp;
 };

 //----------------------------------------------------------------------------
 // Prototypes
 //----------------------------------------------------------------------------

 // __ except_handler3 - функция RTL Visual C++. Мы хотим обратиться к ней,
 // чтобы вывести на экран её адрес.  Однако, т.к. она не представлена в заголовочных
 // файлах нам нужен ее псевдокод.

 extern "C" int _except_handler3(PEXCEPTION_RECORD, EXCEPTION_REGISTRATION *,
                                 PCONTEXT, PEXCEPTION_RECORD);


 //----------------------------------------------------------------------------
 // Code
 //----------------------------------------------------------------------------

 //
 // Отобразить на экране информацию об одном SEH-фрейме, наряду с его scopetable.
 //
 void ShowSEHFrame( VC_EXCEPTION_REGISTRATION * pVCExcRec )
 {
     printf( "Frame: %08X  Handler: %08X  Prev: %08X  Scopetable: %08X\n",
             pVCExcRec, pVCExcRec-&gt;handler, pVCExcRec-&gt;prev,
             pVCExcRec-&gt;scopetable );

     scopetable_entry * pScopeTableEntry = pVCExcRec-&gt;scopetable;

     for ( unsigned i = 0; i &lt;= pVCExcRec-&gt;trylevel; i++ )
     {
         printf( "    scopetable[%u] PrevTryLevel: %08X  "
                 "filter: %08X  __except: %08X\n", i,
                 pScopeTableEntry-&gt;previousTryLevel,
                 pScopeTableEntry-&gt;lpfnFilter,
                 pScopeTableEntry-&gt;lpfnHandler );

         pScopeTableEntry++;
     }

     printf( "\n" );
 }

 //
 // Обходим связанный список обработчиков, и по очереди отображаем информацию
 // о каждом из них.

 void WalkSEHFrames( void )
 {
     VC_EXCEPTION_REGISTRATION * pVCExcRec;

     // Вывести на экран местоположение функции __ except_handler3.
     printf( "_except_handler3 расположен по адресу: %08X\n", _except_handler3 );
     printf( "\n" );

     // Получить указатель на начало списка из FS:[0]
     __asm   mov eax, FS:[0]
     __asm   mov [pVCExcRec], EAX

     // Делаем перебор связанного списка фреймов.  Значение 0xFFFFFFFF
     // сигнализирует об окончании списка.
     while (  0xFFFFFFFF != (unsigned)pVCExcRec )
     {
         ShowSEHFrame( pVCExcRec );
         pVCExcRec = (VC_EXCEPTION_REGISTRATION *)(pVCExcRec-&gt;prev);
     }
 }

 void Function1( void )
 {
     // Установить три вложенные _try-блоки (вследствие этого, появляется три
     // элемента scopetable).
     _try
     {
         _try
         {
             _try
             {
                 WalkSEHFrames();    // Показать все SEH-фреймы.
             }
             _except( EXCEPTION_CONTINUE_SEARCH )
             {
             }
         }
         _except( EXCEPTION_CONTINUE_SEARCH )
         {
         }
     }
     _except( EXCEPTION_CONTINUE_SEARCH )
     {
     }
 }

 int main()
 {
     int i;

     // Используем два _try-блока (не вложенные).  Это вызывает генерацию двух
     // элементов scopetable для этой функции.
     _try
     {
         i = 0x1234;     // Не делаем ничего особенного.
     }
     _except( EXCEPTION_CONTINUE_SEARCH )
     {
         i = 0x4321;     // Ничего особенного (в обратном порядке)
     }

     _try
     {
         Function1();    // Вызываем функцию, которая установит побольше SEH-фреймов.
     }
     _except( EXCEPTION_EXECUTE_HANDLER )
     {
         // Сюда управление передано не будет, т.к. мы не ожидаем исключения.
         printf( "Caught Exception in main\n" );
     }

     return 0;
 }
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 10. ShowSEHFrames.cpp</B></CENTER>
<P>В процессе своей работы функция <B>ShowSEHFrame</B> выводит на экран адрес
<B>SEH</B>-фрейма, адрес <B>callback</B>-функции обработчика исключений, адрес
предыдущего <B>SEH</B>-фрейма и указатель на <B>scopetable</B>. Затем, для
каждого элемента <B>scopetable</B>, она выводит на экран предыдущий
<B>trylevel</B>, адрес выражения-фильтра и адрес <B>_except</B>-блока. Каким
образом я узнаю, сколько элементов содержится в <B>scopetable</B>? На самом
деле, я этого не знаю. Скорее, я предполагаю, что текущий <B>trylevel</B> в
структуре <B>VC_EXCEPTION_REGISTRATION</B> на единицу меньше чем общее
количество элементов в <B>scopetable</B>.
<P>На рис. 11 показаны результат выполнения программы <B>ShowSEHFrames</B>.
Сначала, исследуйте каждую строчку, которая начинается с <I>"Frame:"</I>.
Обратите внимание, что каждый следующий показанный экземпляр <B>SEH</B>-фрейма
находится в стеке выше предыдущего. Затем, обратите внимание, что первые три
строки, начинающиеся с <I>"Frame: "</I>, имеют одно и то же значение в поле
<B>Handler</B> (<B>004012A8</B>). Посмотрев в начало информации, выданной
программой, вы увидите, что это значение (<B>004012A8</B>) соответствует адресу
функции <B>__except_handler3</B> находящейся в <B>RTL Visual C++</B>. Это
доказывает сделанное мной ранее утверждение, что существует только одна точка
входа для всех обработчиков исключений.
<TABLE cellSpacing=0 cellPadding=0 width=500 align=center border=1>
  <TBODY>
  <TR>
    <TD align=middle height=208><IMG height=209 alt="" src="image008.gif"
      width=501 border=0></TD></TR>
  <TR>
    <TD align=middle><STRONG>Рисунок 11. Результат работы программы
      ShowSEHFrames. </STRONG></TD></TR></TBODY></TABLE>
<P>У вас может возникнуть вопрос: почему программа показала три
<B>SEH</B>-фрейма, использующих в качестве <B>callback</B>-обработчика функцию
<B>__except_handler3</B>, в то время как в функции <B>ShowSEHFrames</B> явно
указанны только две функции, использующие <B>SEH</B>? Третий фрейм
устанавливается в <B>RTL Visual C++</B>. В коде находящемся в файле
<B>CRT0.C</B>, который можно найти в исходниках <B>RTL Visual C++</B>, видно,
что вызов функции main или <B>WinMain</B> обернут <B>_try/_except</B>-блоком.
Код выражения-фильтра для этого <B>_try</B>-блока можно найти в файле
<B>WINXFLTR.C</B>.
<P>Вернемся к программе <B>ShowSEHFrames</B>, значение поля <B>Handler</B> в
последней строчке начинающейся с <I>"Frame:"</I> содержит уже другой адрес -
<B>77F3AB6C</B>. Немного пошуровав вокруг, вы поймете, что этот адрес находится
в <B>KERNEL32.DLL</B>. Этот специфический фрейм установлен, описанной мной
ранее, функцией <B>BaseProcessStart</B>, которая находится в
<B>KERNEL32.DLL</B>.
<H2>Раскрутка</H2>
<P>Перед тем как погрузиться в код, осуществляющий раскрутку (<B>unwinding</B>),
давайте кратко обсудим, что это собственно такое. Ранее я описал, как
потенциальные обработчики исключений сохраняется в связанном списке, на который
указывает первый <B>DWORD</B> в <B>TIB</B> (<B>FS:[0]</B>). Так как нужный
обработчик исключения может находиться не в начале списка, необходим механизм
для удаления всех обработчиков исключений находящихся в списке перед ним.
<P>Как вы видели в <B>Visual C++</B>-функции <B>__except_handler3</B>, раскрутка
реализуется с помощью <B>RTL</B>-функции <B>__global_unwind2</B>. Эта функция
представляет собой очень тонкую обертку вокруг не документированной
<B>API</B>-функции <B>RtlUnwind</B>:
<BLOCKQUOTE><PRE>__global_unwind2(void * pRegistFrame)
 {
     _RtlUnwind( pRegistFrame,
                 &amp;__ret_label,
                 0, 0 );
     __ret_label:
 }
</PRE></BLOCKQUOTE>
<P>Хотя функция <B>RtlUnwind</B> является критически важным <B>API</B> для
реализации <B>SEH</B> на уровне компилятора, она нигде не документирована. Хотя
технически эта функция располагается в <B>KERNEL32</B>, в <B>Windows NT
KERNEL32.DLL</B> переадресует ее вызов к <B>NTDLL.DLL</B>, который также имеет
функцию <B>RtlUnwind</B>. На рис. 12 показан примерный псевдокод, который я
набросал для неё.
<BLOCKQUOTE><PRE>void _RtlUnwind( PEXCEPTION_REGISTRATION pRegistrationFrame,
                  PVOID returnAddr,  // Не используется на процессорах i386+!
                  PEXCEPTION_RECORD pExcptRec,
                  DWORD _eax_value )
 {
     DWORD   stackUserBase;
     DWORD   stackUserTop;
     PEXCEPTION_RECORD pExcptRec;
     EXCEPTION_RECORD  exceptRec;
     CONTEXT context;

     // Получаем границы стека из FS:[4] и FS:[8].
     RtlpGetStackLimits( &amp;stackUserBase, &amp;stackUserTop );

     if ( 0 == pExcptRec )   // Нормальный случай.
     {
         pExcptRec = &amp;excptRec;

         pExcptRec-&gt;ExceptionFlags = 0;
         pExcptRec-&gt;ExceptionCode = STATUS_UNWIND;
         pExcptRec-&gt;ExceptionRecord = 0;
         // Получить адрес возврата из стека.
         pExcptRec-&gt;ExceptionAddress = RtlpGetReturnAddress();
         pExcptRec-&gt;ExceptionInformation[0] = 0;
     }

     if ( pRegistrationFrame )
         pExcptRec-&gt;ExceptionFlags |= EXCEPTION_UNWINDING;
     else
         pExcptRec-&gt;ExceptionFlags|=(EXCEPTION_UNWINDING|EXCEPTION_EXIT_UNWIND);

     context.ContextFlags =
         (CONTEXT_i486 | CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS);

     RtlpCaptureContext( &amp;context );

     context.Esp += 0x10;
     context.Eax = _eax_value;

     PEXCEPTION_REGISTRATION pExcptRegHead;

     pExcptRegHead = RtlpGetRegistrationHead();  // Восстанавливаем значение в FS:[0].

     // Начинаем перебор связанного списка структур EXCEPTION_REGISTRATION
     while ( -1 != pExcptRegHead )
     {
         EXCEPTION_RECORD excptRec2;

         if ( pExcptRegHead == pRegistrationFrame )
         {
             _NtContinue( &amp;context, 0 );
         }
         else
         {
             // Если начало связанного списка структур EXCEPTION_REGISTRATION
             // находится в более старшем адресе, чем тот адрес,
             // который был передан в эту функцию в параметре pRegistrationFrame,
             // считаем, что возникла проблема.
             if ( pRegistrationFrame &amp;&amp; (pRegistrationFrame &lt;= pExcptRegHead) )
             {
                 // Чтобы сообщить ОС о возникшей ситуации, вызываем исключение.
                 excptRec2.ExceptionRecord = pExcptRec;
                 excptRec2.NumberParameters = 0;
                 excptRec2.ExceptionCode = STATUS_INVALID_UNWIND_TARGET;
                 excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

                 _RtlRaiseException( &amp;exceptRec2 );
             }
         }

         PVOID pStack = pExcptRegHead + 8; // 8==sizeof(EXCEPTION_REGISTRATION)

         if (    (stackUserBase &lt;= pExcptRegHead ) // Удостоверяемся что
             &amp;&amp;  (stackUserTop &gt;= pStack ) // адрес находящийся в pExcptRegHead
             &amp;&amp;  (0 == (pExcptRegHead &amp; 3)) ) // выровнен на границе DWORD.
         {
             DWORD pNewRegistHead;
             DWORD retValue;

             retValue = RtlpExecutehandlerForUnwind(
                             pExcptRec, pExcptRegHead, &amp;context,
                             &amp;pNewRegistHead, pExceptRegHead-&gt;handler );

             if ( retValue != DISPOSITION_CONTINUE_SEARCH )
             {
                 if ( retValue != DISPOSITION_COLLIDED_UNWIND )
                 {
                     excptRec2.ExceptionRecord = pExcptRec;
              excptRec2.NumberParameters = 0;
                     excptRec2.ExceptionCode = STATUS_INVALID_DISPOSITION;
                     excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

                     RtlRaiseException( &amp;excptRec2 );
                 }
                 else
                     pExcptRegHead = pNewRegistHead;
             }

             PEXCEPTION_REGISTRATION pCurrExcptReg = pExcptRegHead;
             pExcptRegHead = pExcptRegHead-&gt;prev;

             RtlpUnlinkHandler( pCurrExcptReg );
         }
         else    // Адрес не выровнен!  Чтобы сообщить ОС о возникшей ситуации,
                 // вызываем исключение.
         {
             excptRec2.ExceptionRecord = pExcptRec;
             excptRec2.NumberParameters = 0;
             excptRec2.ExceptionCode = STATUS_BAD_STACK;
             excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;

             RtlRaiseException( &amp;excptRec2 );
         }
     }

     // Если управление дошло сюда, значит, мы достигли конца списка
     // EXCEPTION_REGISTRATION.
     // Это обычно не происходит.

     if ( -1 == pRegistrationFrame )
         NtContinue( &amp;context, 0 );
     else
         NtRaiseException( pExcptRec, &amp;context, 0 );

 }

 PEXCEPTION_REGISTRATION
 RtlpGetRegistrationHead( void )
 {
     return FS:[0];
 }

 _RtlpUnlinkHandler( PEXCEPTION_REGISTRATION pRegistrationFrame )
 {
     FS:[0] = pRegistrationFrame-&gt;prev;
 }

 void _RtlpCaptureContext( CONTEXT * pContext )
 {
     pContext-&gt;Eax = 0;
     pContext-&gt;Ecx = 0;
     pContext-&gt;Edx = 0;
     pContext-&gt;Ebx = 0;
     pContext-&gt;Esi = 0;
     pContext-&gt;Edi = 0;
     pContext-&gt;SegCs = CS;
     pContext-&gt;SegDs = DS;
     pContext-&gt;SegEs = ES;
     pContext-&gt;SegFs = FS;
     pContext-&gt;SegGs = GS;
     pContext-&gt;SegSs = SS;
     pContext-&gt;EFlags = flags; // __asm{ PUSHFD / pop [xxxxxxxx] }
     pContext-&gt;Eip = адрес следующей инструкции в защищенном коде
     (т.е. в том коде, где произошло исключение).
     pContext-&gt;Ebp = значение регистра EBP в защищенном коде
     (т.е. в том коде, где произошло исключение).
     pContext-&gt;Esp = Context.Ebp + 8
 }
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 12. Псевдокод RtlUnwind.</B></CENTER>
<P>Хотя <B>RtlUnwind</B> выглядит внушительно, её не сложно понять, если быть
внимательным. Работа этой <B>API</B> начинается с того, что она получает текущую
верхнюю и нижнюю границу стека потока из <B>FS:[4]</B> и <B>FS:[8]</B>. Эти
значения будут важны позже при проверке того, что все раскручиваемые кадры
исключений находятся внутри области стека.
<P>Далее <B>RtlUnwind</B> создает в стеке фиктивную структуру
<B>EXCEPTION_RECORD</B>, и устанавливает в поле <B>ExceptionCode</B> значение
<B>STATUS_UNWIND</B>. Также, устанавливается флажок <B>EXCEPTION_UNWINDING</B> в
поле <B>ExceptionFlags</B> принадлежащем этой структуре. Позже указатель на эту
структуру будет передаваться в качестве параметра каждому обработчику
исключений. После этого, она вызывает функцию <B>_RtlpCaptureContext</B>, чтобы
создать фиктивную структуру <B>CONTEXT</B>, которая также будет использоваться в
качестве параметра при вызовах обработчиков исключений для раскрутки.
<P>Остальная часть <B>RtlUnwind</B> занимается перебором элементов в связанном
списке структур <B>EXCEPTION_REGISTRATION</B>. Её код, для каждого фрейма,
вызывает функцию <B>RtlpExecuteHandlerForUnwind</B>, которую я рассмотрю позже.
Именно эта функция вызывает обработчик исключений с установленным флажком
<B>EXCEPTION_UNWINDING</B>. После каждого вызова, соответствующий фрейм
исключения удаляется с помощью вызова функции <B>RtlpUnlinkHandler</B>.
<P><B>RtlUnwind</B> заканчивает раскрутку фреймов, после того как добирается до
фрейма адрес которого был передан ему в первом параметре. В код, который я
описал, включён код проверки обеспечивающий правильное выполнение. Если случится
какая-нибудь неприятность делающая продолжение раскрутки невозможным,
<B>RtlUnwind</B> вызовет исключение, указывающее тип проблемы, и такое
исключение будет иметь установленный флажок <B>EXCEPTION_NONCONTINUABLE</B>.
Если у возникшего исключения установлен этот флажок, система не даст процессу, в
котором оно возникло, продолжить свою работу, уничтожив его.
<H2>Необработанные исключения</H2>
<P>Ранее в статье, я откладывал полное описание <B>API
UnhandledExceptionFilter</B>. Обычно вам не нужно вызывать эту <B>API</B>
напрямую (хотя вы можете это сделать). В большинстве случаев, её вызывает код
выражения-фильтра из дефолтного обработчика исключений находящегося в
<B>KERNEL32</B>. Это показано в приведенном ранее псевдокоде функции
<B>BaseProcessStart</B>.
<P>На рис. 13 показан написанный мой псевдокод функции
<B>UnhandledExceptionFilter</B>. Её начало выглядит немного странно (по крайней
мере, мне так кажется). Если произошедшая ошибка -
<B>EXCEPTION_ACCESS_VIOLATION</B>, код вызывает функцию
<B>_BasepCheckForReadOnlyResource</B>. Хотя я не представил здесь псевдокод этой
функции, тем не менее, я могу описать ее работу. Если исключение возникло, из-за
попытки записи в раздел ресурсов (<B>.rsrc</B>) в <B>EXE</B> или <B>DLL</B>,
функция <B>_BasepCurrentTopLevelFilter</B> изменяет атрибуты страницы, при
обращении к которой произошло исключение (в нормальном состоянии эта страница
имеет атрибут <B>"Read Only"</B>), тем самым, разрешая запись на эту страницу.
Если происходит именно это, <B>UnhandledExceptionFilter</B> возвращает значение
<B>EXCEPTION_CONTINUE_EXECUTION</B>, после чего происходит рестарт операции
вызвавшей исключение.
<BLOCKQUOTE><PRE>UnhandledExceptionFilter( STRUCT _EXCEPTION_POINTERS *pExceptionPtrs )
 {
     PEXCEPTION_RECORD pExcptRec;
     DWORD currentESP;
     DWORD retValue;
     DWORD DEBUGPORT;
     DWORD   dwTemp2;
     DWORD   dwUseJustInTimeDebugger;
     CHAR    szDbgCmdFmt[256];   // Шаблон строки получаемой из ключа системного
                                 // реестра: AeDebug.
     CHAR    szDbgCmdLine[256];  // После заполнения, здесь будет находиться
                                 // командная строка для вызова отладчика.
     STARTUPINFO startupinfo;
     PROCESS_INFORMATION pi;
     HARDERR_STRUCT  harderr;    // ???
     BOOL fAeDebugAuto;
     TIB * pTib;                 // Блок информации потока (TIB)

     pExcptRec = pExceptionPtrs-&gt;ExceptionRecord;

     if (   (pExcptRec-&gt;ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
         &amp;&amp; (pExcptRec-&gt;ExceptionInformation[0]) )
     {
         retValue =
             _BasepCheckForReadOnlyResource(pExcptRec-&gt;ExceptionInformation[1]);

         if ( EXCEPTION_CONTINUE_EXECUTION == retValue )
             return EXCEPTION_CONTINUE_EXECUTION;
      }

     // Смотрим, выполняется ли этот процесс под управлением отладчика.
     retValue = NtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort,
                                          &amp;debugPort, sizeof(debugPort), 0 );

     if ( (retValue &gt;= 0) &amp;&amp; debugPort )     // Передаем исключение отладчику.
         return EXCEPTION_CONTINUE_SEARCH;

     // Вызывала ли пользовательская программа API-функцию
     // SetUnhandledExceptionFilter?  Если да, вызываем установленную
     // ей функцию обратного вызова (т.е. производим обратный вызов).

     if ( _BasepCurrentTopLevelFilter )
     {
         retValue = _BasepCurrentTopLevelFilter( pExceptionPtrs );

         if ( EXCEPTION_EXECUTE_HANDLER == retValue )
             return EXCEPTION_EXECUTE_HANDLER;

         if ( EXCEPTION_CONTINUE_EXECUTION == retValue )
             return EXCEPTION_CONTINUE_EXECUTION;

         // Далее обрабатываются только EXCEPTION_CONTINUE_SEARCH.
     }

     // Вызывалась ли функция SetErrorMode с параметром SEM_NOGPFAULTERRORBOX?
     if ( 0 == (GetErrorMode() &amp; SEM_NOGPFAULTERRORBOX) )
     {
         harderr.elem0 = pExcptRec-&gt;ExceptionCode;
         harderr.elem1 = pExcptRec-&gt;ExceptionAddress;

         if ( EXCEPTION_IN_PAGE_ERROR == pExcptRec-&gt;ExceptionCode )
             harderr.elem2 = pExcptRec-&gt;ExceptionInformation[2];
         else
             harderr.elem2 = pExcptRec-&gt;ExceptionInformation[0];

         dwTemp2 = 1;
         fAeDebugAuto = FALSE;

         harderr.elem3 = pExcptRec-&gt;ExceptionInformation[1];

         pTib = FS:[18h];

         DWORD someVal = pTib-&gt;pProcess-&gt;0xC;

         if ( pTib-&gt;threadID != someVal )
         {
             __try
            {
                 char szDbgCmdFmt[256]
                 retValue = _GetProfileStringA( "AeDebug", "Debugger", 0,
                                      szDbgCmdFmt, sizeof(szDbgCmdFmt)-1 );

                 if ( retValue )
                     dwTemp2 = 2;

                 char szAuto[8]

                 retValue = GetProfileStringA(   "AeDebug", "Auto", "0",
                                                 szAuto, sizeof(szAuto)-1 );
                 if ( retValue )
                     if ( 0 == strcmp( szAuto, "1" ) )
                         if ( 2 == dwTemp2 )
                             fAeDebugAuto = TRUE;
             }
             __except( EXCEPTION_EXECUTE_HANDLER )
             {
                 ESP = currentESP;
                 dwTemp2 = 1
                 fAeDebugAuto = FALSE;
             }
         }

         if ( FALSE == fAeDebugAuto )
         {
             retValue =  NtRaiseHardError(
                                 STATUS_UNHANDLED_EXCEPTION | 0x10000000,
                                 4, 0, &amp;harderr,
                                 _BasepAlreadyHadHardError ? 1 : dwTemp2,
                                 &amp;dwUseJustInTimeDebugger );
         }
         else
         {
             dwUseJustInTimeDebugger = 3;
             retValue = 0;
         }

         if (    retValue &gt;= 0
             &amp;&amp;  ( dwUseJustInTimeDebugger == 3)
             &amp;&amp;  ( !_BasepAlreadyHadHardError )
             &amp;&amp;  ( !_BaseRunningInServerProcess ) )
         {
             _BasepAlreadyHadHardError = 1;

             SECURITY_ATTRIBUTES secAttr = { sizeof(secAttr), 0, TRUE };

             HANDLE hEvent = CreateEventA( &amp;secAttr, TRUE, 0, 0 );

             memset( &amp;startupinfo, 0, sizeof(startupinfo) );

             sprintf(szDbgCmdLine, szDbgCmdFmt, GetCurrentProcessId(), hEvent);

             startupinfo.cb = sizeof(startupinfo);
             startupinfo.lpDesktop = "Winsta0\Default"

             CsrIdentifyAlertableThread();   // ???

             retValue = CreateProcessA(
                             0,              // lpApplicationName
                             szDbgCmdLine,   // Коммандная строка
                             0, 0,           // атрибуты защиты процесса и потока
                             1,              // bInheritHandles
                             0, 0,           // флаги (влияющие на то, как именно
                                             // создается новый процесс) и блок
                                             // переменных окружения
                             0,              // текущая директория.
                             &amp;statupinfo,    // STARTUPINFO
                             &amp;pi );          // PROCESS_INFORMATION

             if ( retValue &amp;&amp; hEvent )
             {
                 NtWaitForSingleObject( hEvent, 1, 0 );
                 return EXCEPTION_CONTINUE_SEARCH;
             }
         }

         if ( _BasepAlreadyHadHardError )
             NtTerminateProcess(GetCurrentProcess(), pExcptRec-&gt;ExceptionCode);
     }

     return EXCEPTION_EXECUTE_HANDLER;
 }

 LPTOP_LEVEL_EXCEPTION_FILTER
 SetUnhandledExceptionFilter(
     LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter );
 {
     // Глобальная переменная _BasepCurrentTopLevelFilter находится в KERNEL32.DLL.
     LPTOP_LEVEL_EXCEPTION_FILTER previous= _BasepCurrentTopLevelFilter;

     // Устанавливаем новое значение.
     _BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;

     return previous;    // Возвращаем старое значение.
 }
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 13. Псевдокод UnHandledExceptionFilter.</B></CENTER>
<P>Следующая задача <B>UnhandledExceptionFilter</B> состоит в том, чтобы
определить, выполняется ли процесс под управлением <B>Win32</B>-отладчика. То
есть, был ли, при создании этого процесса, установлен флажок
<B>DEBUG_ONLY_THIS_PROCESS</B>, или флажок <B>DEBUG_PROCESS</B>.
<B>UnhandledExceptionFilter</B> использует для этого функцию
<B>NtQueryInformationProcess</B> (эту функцию я описывал в этом месяце, в
колонке <B>Under the Hood</B>). Если процесс действительно запущен под
отладчиком, <B>UnhandledExceptionFilter</B> возвращает значение
<B>EXCEPTION_CONTINUE_SEARCH</B>, которое заставляет ОС разбудить отладчик, и
сообщить ему, что произошло исключение в отлаживаемой им программе.
<P>Затем <B>UnhandledExceptionFilter</B> вызывает установленный пользователем
фильтр необрабатываемых исключений, если он присутствует. Обычно, эта
<B>callback</B>-функция отсутствует, но может быть установлена с помощью
<B>API</B>-функции <B>SetUnhandledExceptionFilter</B>. Я не буду приводить здесь
псевдокод для этой <B>API</B>. <B>API UnhandledExceptionFilter</B> просто
помещает в глобальную переменную новый адрес пользовательской
<B>callback</B>-функции, и возвращает адрес старой.
<P>После подготовительных мероприятий, <B>UnhandledExceptionFilter</B> может
переходить к своей основной задаче: информировать вас о вашей позорной ошибке в
программе, с помощью стильного диалога <B>Application Error</B>. Существует два
пути, следуя которым можно избежать появления этого диалога. Первый путь
заключается в том, что процесс должен вызвать (до возникновения исключения)
функцию <B>SetErrorMode</B>, указав ей флажок <B>SEM_NOGPFAULTERRORBOX</B>.
Другой метод состоит в том, что значение параметра <B>Auto</B>, находящегося в
разделе системного реестра AeDebug, должно быть равно единице. В этом случае,
<B>UnhandledExceptionFilter</B> не показывает диалог <B>Application Error</B>, а
вместо этого автоматически запускает отладчик, который определен в параметре
<B>Debugger</B>, находящийся в разделе системного реестра <B>AeDebug</B>. Если
вы знакомы с механизмом <B>"just in time debugging"</B> то знайте, что именно с
помощью этого операционная система поддерживает данный механизм. Позже мы
поговорим об этом более подробно.
<P>В большинстве случаев, ни один из этих путей не используется, и
<B>UnhandledExceptionFilter</B> вызывает функцию <B>NtRaiseHardError</B>,
находящуюся в <B>NTDLL.DLL</B>. Именно эта функция показывает диалог
<B>Application Error</B>. Этот диалог ждет, пока вы нажмете на нем какую-либо
кнопку: или <B>OK</B>, чтобы завершить процесс, или <B>Cancel</B>, чтобы начать
его отладку (лично мне кажется использование кнопки <B>Cancel</B> для запуска
отладчика немного извращённым).
<P>Если в диалоговом окне <B>Application Error</B> вы нажмете <B>OK</B>,
<B>UnhandledExceptionFilter</B> вернет значение
<B>EXCEPTION_EXECUTE_HANDLER</B>. Код, вызвавший
<B>UnhandledExceptionFilter</B>, обычно реагирует на это, завершением своей
работы (как вы видели в коде <B>BaseProcessStart</B>). Здесь приоткрывается один
интересный момент. Большинство людей считает, что система завершает процесс, не
обрабатывая исключение. На самом деле, правильнее будет сказать, что система
делает так, чтобы необработанное исключение заставило процесс завершить самого
себя.
<P>Действительно интересный код в <B>UnhandledExceptionFilter</B> выполняется в
том случае, если в диалоге <B>Application Error</B> вы выбираете <B>Cancel</B>,
он обеспечивает прикрепление отладчика к процессу, вызвавшему исключение. Код
сначала вызывает <B>CreateEvent</B>, чтобы создать объект Событие, через которое
отладчик сообщит, что он подключился к сбойному процессу. Дескриптор этого
объекта, наряду с идентификатором текущего процесса (<B>process ID</B>),
передается в функцию <B>sprintf</B>, которая формирует командную строку,
используемую для запуска отладчика. Как только всё готово,
<B>UnhandledExceptionFilter</B> вызывает функцию <B>CreateProcess</B>, для
запуска отладчика. Если выполнение <B>CreateProcess</B> пройдет нормально, код
вызывает функцию <B>NtWaitForSingleObject</B>, и передает ей дескриптор объекта
Событие, который был создан ранее. Этот вызов производит блокировку до тех пор,
пока отладчик не просигналит через объект Событие, что его прикрепление к
сбойному процессу прошло успешно. На данный момент в
<B>UnhandledExceptionFilter</B> еще остались небольшие темные пятна, но самое
важное я здесь осветил.
<H2>Инферно</H2>
<P>Раз вы зашли так далеко, было бы несправедливо остановиться, не разобравшись
во всем этом до конца. Я показал, как операционная система вызывает определяемую
пользователем функцию, когда происходит исключение. Я показал, что обычно
происходит внутри этих <B>callback</B>-функций, и как компиляторы используют их,
для реализации <B>_try</B> и <B>_catch</B>. Я даже показал, что происходит,
когда никто не обрабатывает исключение, и система должна делать очистку. Все,
что осталось - это показать, где начинается работа обработчиков. Да, давайте
погрузимся во внутренности системы, и посмотрим начальные этапы выполнения
<B>SEH</B>.
<P>На рис. 14 показан примерный, сделанный мной на скорую руку, псевдокод
функции <B>KiUserExceptionDispatcher</B> и некоторых других, связанных с ней,
функций. <B>KiUserExceptionDispatcher</B> находится в <B>NTDLL.DLL</B>, и именно
она начинает выполняться первой при возникновении исключения. Если быть на 100
процентов точным, это не совсем так. Например, в <B>Intel</B>-архитектуре
возникновение исключения вызывает передачу управления по вектору в обработчик
находящийся в нулевом кольце защиты, т.е. в обработчик режима ядра (<B>kernel
mode</B>). Обработчик определен соответствующим исключению элементом таблицы
дескрипторов прерываний (она же - <B>Interrupt Descriptor Table</B>, или просто
- <B>IDT</B>). Я собираюсь пропустить все, что касается кода уровня ядра, и
притвориться, что, при возникновении исключения, <B>CPU</B> передает управление
прямо в <B>KiUserExceptionDispatcher</B>.
<BLOCKQUOTE><PRE>KiUserExceptionDispatcher( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext )
 {
     DWORD retValue;

     // Обратите внимание: Если исключение обработано, RtlDispatchException()
     // никогда не возвращает управления.
     if ( RtlDispatchException( pExceptRec, pContext ) )
         retValue = NtContinue( pContext, 0 );
     else
         retValue = NtRaiseException( pExceptRec, pContext, 0 );

     EXCEPTION_RECORD excptRec2;

     excptRec2.ExceptionCode = retValue;
     excptRec2.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
     excptRec2.ExceptionRecord = pExcptRec;
     excptRec2.NumberParameters = 0;

     RtlRaiseException( &amp;excptRec2 );
 }

 int RtlDispatchException( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext )
 {
     DWORD   stackUserBase;
     DWORD   stackUserTop;
     PEXCEPTION_REGISTRATION pRegistrationFrame;
     DWORD hLog;

     // Получаем границы стека из FS:[4] и FS:[8]
     RtlpGetStackLimits( &amp;stackUserBase, &amp;stackUserTop );

     pRegistrationFrame = RtlpGetRegistrationHead();

     while ( -1 != pRegistrationFrame )
     {
         PVOID justPastRegistrationFrame = &amp;pRegistrationFrame + 8;
         if ( stackUserBase &gt; justPastRegistrationFrame )
         {
             pExcptRec-&gt;ExceptionFlags |= EH_STACK_INVALID;
             return DISPOSITION_DISMISS; // 0
         }

         if ( stackUsertop &lt; justPastRegistrationFrame )
         {
             pExcptRec-&gt;ExceptionFlags |= EH_STACK_INVALID;
             return DISPOSITION_DISMISS; // 0
         }

         if ( pRegistrationFrame &amp; 3 )   // Удостоверяемся что стек выровнен
                                         // на границе DWORD.
         {
             pExcptRec-&gt;ExceptionFlags |= EH_STACK_INVALID;
             return DISPOSITION_DISMISS; // 0
         }

         if ( someProcessFlag )
         {
             // Doesn't seem to do a whole heck of a lot.
             hLog = RtlpLogExceptionHandler( pExcptRec, pContext, 0,
                                             pRegistrationFrame, 0x10 );
         }

         DWORD retValue, dispatcherContext;

         retValue= RtlpExecuteHandlerForException(pExcptRec, pRegistrationFrame,
                                                  pContext, &amp;dispatcherContext,
                                                  pRegistrationFrame-&gt;handler );

         // Doesn't seem to do a whole heck of a lot.
         if ( someProcessFlag )
             RtlpLogLastExceptionDisposition( hLog, retValue );

         if ( 0 == pRegistrationFrame )
         {
             pExcptRec-&gt;ExceptionFlags &amp;= ~EH_NESTED_CALL;   // Сбрасываем флажок.
         }

         EXCEPTION_RECORD excptRec2;

         DWORD yetAnotherValue = 0;

         if ( DISPOSITION_DISMISS == retValue )
         {
             if ( pExcptRec-&gt;ExceptionFlags &amp; EH_NONCONTINUABLE )
             {
                 excptRec2.ExceptionRecord = pExcptRec;
                 excptRec2.ExceptionNumber = STATUS_NONCONTINUABLE_EXCEPTION;
                 excptRec2.ExceptionFlags = EH_NONCONTINUABLE;
                 excptRec2.NumberParameters = 0
                 RtlRaiseException( &amp;excptRec2 );
             }
             else
                 return DISPOSITION_CONTINUE_SEARCH;
         }
         else if ( DISPOSITION_CONTINUE_SEARCH == retValue )
         {
         }
         else if ( DISPOSITION_NESTED_EXCEPTION == retValue )
         {
             pExcptRec-&gt;ExceptionFlags |= EH_EXIT_UNWIND;
             if ( dispatcherContext &gt; yetAnotherValue )
                 yetAnotherValue = dispatcherContext;
         }
         else    // DISPOSITION_COLLIDED_UNWIND
         {
             excptRec2.ExceptionRecord = pExcptRec;
             excptRec2.ExceptionNumber = STATUS_INVALID_DISPOSITION;
             excptRec2.ExceptionFlags = EH_NONCONTINUABLE;
             excptRec2.NumberParameters = 0
             RtlRaiseException( &amp;excptRec2 );
         }

         pRegistrationFrame = pRegistrationFrame-&gt;prev;
         // Перейти к предыдущему фрейму.
     }

     return DISPOSITION_DISMISS;
 }


 _RtlpExecuteHandlerForException:    // Обрабатываем исключение (в основном режиме).
     MOV     EDX,XXXXXXXX
     JMP     ExecuteHandler


 RtlpExecutehandlerForUnwind:        // Обрабатываем раскрутку (в режиме раскрутки).
     MOV     EDX,XXXXXXXX



 int ExecuteHandler( PEXCEPTION_RECORD pExcptRec
                     PEXCEPTION_REGISTRATION pExcptReg
                     CONTEXT * pContext
                     PVOID pDispatcherContext,
                     FARPROC handler )
                     // Действительный указатель на _except_handler()

     // Устанавливаем EXCEPTION_REGISTRATION, здесь в регистре EDX
     // содержится адрес кода соответствующего обработчика,
     // который показан ниже.
     PUSH    EDX
     PUSH    FS:[0]
     MOV     FS:[0],ESP

     // Вызываем callback-функцию обработчика исключений.
     EAX = handler( pExcptRec, pExcptReg, pContext, pDispatcherContext );

     // Удаляем голый фрейм EXCEPTION_REGISTRATION
     MOV     ESP,DWORD PTR FS:[00000000]
     POP     DWORD PTR FS:[00000000]

     return EAX;
 }

 Обработчик исключений для _RtlpExecuteHandlerForException:
 {
     // Если установлен флажок раскрутки, возвращаем значение
     // DISPOSITION_CONTINUE_SEARCH, в противном случае
     // назначаем pDispatcherContext, и возвращаем значение
     // DISPOSITION_NESTED_EXCEPTION.

     return pExcptRec-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT
                 ? DISPOSITION_CONTINUE_SEARCH
                 : *pDispatcherContext = pRegistrationFrame-&gt;scopetable,
                   DISPOSITION_NESTED_EXCEPTION;
 }

 Обработчик исключений для _RtlpExecuteHandlerForUnwind:
 {
     // Если установлен флажок раскрутки, возвращаем значение
     // DISPOSITION_CONTINUE_SEARCH, в противном случае
     // назначаем pDispatcherContext, и возвращаем значение
     // DISPOSITION_COLLIDED_UNWIND.

     return pExcptRec-&gt;ExceptionFlags &amp; EXCEPTION_UNWIND_CONTEXT
                 ? DISPOSITION_CONTINUE_SEARCH
                 : *pDispatcherContext = pRegistrationFrame-&gt;scopetable,
                   DISPOSITION_COLLIDED_UNWIND;
 }
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 14. Псевдокод KiUserExceptionDispatcher.</B></CENTER>
<P>Основа <B>KiUserExceptionDispatcher</B> - вызов функции
<B>RtlDispatchException</B>. Эта функция начинает поиск любого
зарегистрированного обработчика исключений. Если обработчик решил обработать
исключение, функция <B>RtlDispatchException</B> не вернет управления. Если
происходит возврат из <B>RtlDispatchException</B>, то есть два возможных пути:
или вызывается <B>NtContinue</B>, который позволяет процессу продолжить
выполнение, или вызвать другое исключение. На сей раз, исключение будет не
устранимым (<B>isn't continuable</B>), и, следовательно, процесс должен будет
завершиться.
<P>Перейдем к <B>RtlDispatchExceptionCode</B>, именно здесь вы найдете код
перебора <B>SEH</B>-фреймов, который я часто упоминал в этой статье. Функция
получает указатель на связанный список <B>EXCEPTION_REGISTRATIONs</B>, и
перебирает каждый его узел в поисках обработчика. Из-за возможности искажения
стека, функция очень параноидальна. Перед вызовом обработчика указанного в
каждой структуре <B>EXCEPTION_REGISTRATION</B>, код убеждается в том, что она
(т.е. структура <B>EXCEPTION_REGISTRATION</B>) выровнена на границу
<B>DWORD</B>, находится внутри стека потока, и располагается выше, чем
предыдущая <B>EXCEPTION_REGISTRATION</B>.
<P><B>RtlDispatchException</B> не производит непосредственный вызов адреса
указанного в структуре <B>EXCEPTION_REGISTRATION</B>. Вместо этого, для
выполнения черновой работы, она вызывает <B>RtlpExecuteHandlerForException</B>.
В зависимости от того, что происходит внутри
<B>RtlpExecuteHandlerForException</B>, <B>RtlDispatchException</B>, или
продолжает перебор <B>SEH</B>-фреймов, или инициирует другое исключение.
Вторичное исключение указывает, что в обработчике исключений что-то пошло не
так, как надо, и что выполнение процесса не может быть продолжено.
<P>Код <B>RtlpExecuteHandlerForException</B> тесно связан с другой функцией,
<B>RtlpExecuteHandlerForUnwind</B>. Вспомните, я уже упоминал эту функцию ранее,
когда я описывал раскрутку. Обе этих "функции" просто загружают в регистр
<B>EDX</B> разные значения перед передачей управления функции
<B>ExecuteHandler</B>. Другими словами, <B>RtlpExecuteHandlerForException</B> и
<B>RtlpExecutehandlerForUnwind</B> - это различные точки входа в функцию
<B>ExecuteHandler</B>.
<P>В <B>ExecuteHandler</B> происходит извлечение и вызов адреса взятого из поля
<B>handler</B> структуры <B>EXCEPTION_REGISTRATION</B>. Может показаться
странным, но вызов <B>callback</B>-функции исключения тоже обслуживается
обработчиком <B>SEH</B>. Использование <B>SEH</B> внутри <B>SEH</B> выглядит
немного забавным, но если немного подумать, причина становится ясной. Если
обработчик вызывает другое исключение, ОС должна знать об этом. В зависимости от
того, в каком режиме работал обработчик, во время возникновения исключения: в
основном режиме, или в режиме раскрутки, <B>ExecuteHandler</B> возвращает, или
значение<B> DISPOSITION_NESTED_ EXCEPTION</B>, или значение
<B>DISPOSITION_COLLIDED_UNWIND</B>. Основное значение обоих кодов: "Красная
тревога! Закрыть все сейчас же!" (<I>"Red Alert! Shut everything down
now!"</I>).
<P>Если вы похожи на меня, вам трудно запомнить все функции, связанные с
<B>SEH</B>. Также трудно запомнить, какая из них какую вызывает. Чтобы помочь
себе, я составил диаграмму, показанную на рис. 15.
<BLOCKQUOTE><PRE> KiUserExceptionDispatcher()

     RtlDispatchException()

         RtlpExecuteHandlerForException()

             ExecuteHandler() // Обычно идет в __except_handler3

 ---------

 __except_handler3()

     scopetable filter-expression()

     __global_unwind2()

         RtlUnwind()

             RtlpExecuteHandlerForUnwind()

     scopetable __except block()
</PRE></BLOCKQUOTE>
<CENTER><B>Рисунок 15. Взаимосвязь функций поддерживающих SEH.</B></CENTER>
<P>Теперь, зачем делается установка значения регистра <B>EDX</B> перед переходом
в код <B>ExecuteHandler</B>? На самом деле, здесь все просто. В том случае, если
в процессе работы обработчика установленного пользователем что-то пойдет не так,
как надо, <B>ExecuteHandler</B> использует значение из регистра <B>EDX</B> как
адрес обработчика исключений. Он помещает значение регистра <B>EDX</B> в стек в
качестве поля <B>Handler</B>, принадлежащего минимальной структуре
<B>EXCEPTION_REGISTRATION</B>. В сущности, <B>ExecuteHandler</B> использует
базовый <B>SEH</B> так, как я показал в программах <B>MYSEH</B> и
<B>MYSEH2</B>.
<H2>Заключение</H2>
<P><B>SEH</B> - замечательная особенность <B>Win32</B>. Благодаря
высокоуровневой поддержке, которую, подобно <B>Visual C++</B>, обеспечивают
компиляторы, средний программист может извлечь выгоду из его использования с
относительно небольшими затратами на его изучение. Однако, на уровне
операционной системы, это более сложная вещь, чем можно было бы подумать,
доверившись документации по <B>Win32</B>.
<P>К сожалению, до настоящего времени о <B>SEH</B> было написано очень мало,
потому что почти все считают это чрезвычайно трудной темой. Отсутствие
документации по подробностям системного уровня никому не помогает. В этой
статье, я показал, что <B>SEH</B> уровня системы вращается вокруг относительно
простой концепции функции обратного вызова (<B>callback function</B>). Если вы
поймете природу обратного вызова, и будете в процессе изучения опираться на это
понятие, то механизм <B>SEH</B> не будет для вас слишком сложен.
<P>Оригинал: <A HREF="https://www.microsoft.com/msj/0197/exception/exception.aspx">Matt Pietrek &mdash; A Crash Course on the Depths of Win32™ Structured Exception Handling</A>. Microsoft Systems Journal. Январь 1997.
<P>Перевод Oleg_SK, SI<BR><BR>
</BODY>
</HTML>